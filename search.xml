<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发-线程池的原理及使用]]></title>
    <url>%2F2018%2F09%2F03%2FJava%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[【转载】- 本文摘自《Java并发编程的艺术-方腾飞》 &nbsp;&nbsp;Java中的线程池是运用场景最多的并发框架，几乎所有的异步或并发执行任务的程序都可以使用线程池。在开发中，合理地使用线程池能够带来3个好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。 1. 线程池的原理当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池的主要处理流程，处理流程图如下图所示 线程池的主要处理流程 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务 ThreadPoolExecutor执行execute()方法的示意图 ThreadPooIExecutor执行execute方法分下面4种情况。 如果当前运行的线程少于corePooISize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 如果运行的线程等于或多于corePooISize，则将任务加入BlockingQueue。 如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 如果创建新线程将使当前运行的线程超出maximumPooISize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 ThreadPooIExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPooIExecutor完成预热之后（当前运行的线程数大于等于corePooISize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 源码分析：上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的，线程池执行任务的方法如下。 1234567891011121314151617public void execute (Runnable command)&#123; if(command == null) throw new NullPointerException; //如果线程数小于基本线程数，则创建线程并执行当前任务 if(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))&#123; //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if(runState == RUNNING &amp;&amp; workQueue.offer(command))&#123; if(runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， // 则创建一个线程执行任务 else if(!addIfUnderMaximumPoolSize(command)) //抛出 Rej ectedExecutionException异常 reject(command); &#125;&#125; 工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点 123456789101112public void run()&#123; try&#123; Runnable task = firstTask; firstTask = null; while(task != null || (task = getTask()) != null)&#123; runTask(task); task = null; &#125; &#125;finally&#123; workerDone(this); &#125;&#125; ThreadPoolExecutor中线程执行任务的示意图如下所示： 线程池中的线程执行任务分两种情况，如下 在execute()方法中创建一个线程时，会让这个线程执行当前任务。 这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行 2. 线程池的使用2.1 线程池的创建我们可以通过ThreadPoolExecutor来创建一个线程池 1new ThreadPoolExecutor(corePoolSize, maximumPoolSize,keepAliveTime,TimeUnit, BlockingQueue&lt;Runnable&gt;,ThreadFactory,RejectedExecutionHandler) 创建线程池时需要输入几个参数，如下： 1. corePooISize(线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAIICoreThreads()方法，线程池会提前创建并启动所有基本线程。 2. maximumPooISize(线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 3. keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个执行任务的时间比较短，可以调大时间，提高线程的利用率 4. TimeUnit(线程活动保持时间的单位)：可选的单位有天（DAYS）、小时（HOURS）、分钟( MNUTES)、毫秒(MIIIISECONDS)、微秒（MICROSECONDS，千分之一毫秒）和纳秒(NANOSECONDS，千分之一微秒) 5. BlockingQueue（任务队列）：用来保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列 ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 Executots.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移出操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executor.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列 6. ThreadFactory：(用于设置创建线程的工厂)可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下： 1new ThreadFactoryBuilder().setNameFormat("XX-task-%d").build(); 7. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK1.5中Java线程池框架提供了4种策略1.AbortPolicy：直接抛出异常。2.CallerRunsPolicy：只用调用者所在线程来运行任务。3.DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。4.DiscardPolicy：不处理，丢弃掉。 2.2 向线程池提交任务 可以使用两个方法向线程池提交任务，分别是execute()和submit()方法 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功，可以通过以下代码可知execute()方法输入的是一个Runnable类的实例 123456threadsPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125; &#125;); sublime()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程知道任务完成，而使用get(long timeout, TimeUnit unit)方法则会一直阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 2.3 线程池的关闭 我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，但是它们的实现原理不同; shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表 只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdokwnNow 其他链接 聊聊并发(三) Java线程池的分析与使用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>转载</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-OSI七层网络结构]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[计算网网络OSI七层结构高清大图]]></content>
      <categories>
        <category>面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot核心原理-手写实现spring-boot-starter与自动配置]]></title>
    <url>%2F2018%2F07%2F24%2FSpringBoot%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0spring-boot-starter%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要内容摘自《Java EE的颠覆者 SpringBoot实战-汪云飞》，以下为学习笔记与实现代码，仅供交流学习 1. SpringBoot实现原理&nbsp;&nbsp;Springboot只所以能实现快速开发，其中最重要的特征就是spring-boot-starter与自动配置，前者将常用的依赖分组进行整合，将其合并到一个依赖中；后者则是利用了Spring4.x+对条件化配置的支持，合理地推测应用所需的bean并自动配置他们，这些则符合springboot的设计理念-习惯优于配置，从而大大减少繁多的配置，提高开发效率 2. 实现步骤1. IDEA新建maven项目 2. 修改pom.xml文件12345678910111213141516171819202122232425262728293031&lt;groupId&gt;com.xzp&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-hello&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-starter-hello&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 新建配置属性类 maven创建项目时，如果相关的目录，则可以手动建立 HelloServiceProperties.java 12345678910111213141516171819202122@ConfigurationProperties(prefix = "hello")public class HelloServiceProperties &#123; /** * 默认的msg是world * 可以通过在application.properties中hello.msg= 来设置 */ private static final String MSG = "world"; private String msg = MSG; public static String getMSG() &#123; return MSG; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 4. 判断服务类 该示例中通过判断此类的存在与否来创建这个类的Bean，这个类可以是第三方类库的类 HelloService.java 123456789101112131415public class HelloService &#123; private String msg; public String sayHello()&#123; return "Hello " + msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 5. 自动配置类 HelloServiceAutoConfiguration.java 根据 HelloServiceProperties 提供的参数，并通过＠ConditionalOnClass 判断 HelloService 这 个类在类路径中是否存在，且当容器中没有这个 Bean 的情况下自动配置这个 Bean. 1234567891011121314151617@Configuration@EnableConfigurationProperties(HelloServiceProperties.class) // 1. 开启属性注入@ConditionalOnClass(HelloService.class) // 2. 当HelloService在类路径下@ConditionalOnProperty(prefix = "hello",value = "enabled",matchIfMissing = true) //3. 配置的前缀: hello 当设置hello=enabled的情况下，如果没有设置，则默认true，即条件符合public class HelloServiceAutoConfiguration &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean // 4. 使用Java config配置 @ConditionalOnMissingBean(HelloService.class) //判断HelloService这个类在类路径中是否存在，且当容器中没有这个Bean的情况下自动配置这个Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 6. 注册配置 若想配置生效，需要注册自动配置类。在src/main/resources下新建META-INF/spring.factories,，项目目录结构如下所示： spring.factories内容如下： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xzp.spring_boot_starter_hello.HelloServiceAutoConfiguration 7. 安装到本地库 执行命令：mvn install安装到本地库，或者将这个jar包发布到Maven私服上 1234567tarter-hello-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.500 s[INFO] Finished at: 2018-07-24T19:16:56+08:00[INFO] ------------------------------------------------------------------------ 8. 新建测试项目 新建SpringBoot项目，本文示例为ch6_5项目，对应于书中的章节， 新建测试的Controller， 123456789101112@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping("/") public String index()&#123; return helloService.sayHello(); &#125;&#125; 目录结果如下： 启动SpringBoot，此时application.properties中未添加任何内容,浏览器中输入 localhost:8080,结果如下： 上述结果表明默认的配置生效了，测试我们修改application.properties内容如下，再重新启动 1hello.msg=xiongzp08 则运行结果如下： 可以看到相应的结果发生变化了 如果在application.properties中添加debuge=true，还可以在控制台看到我们的配置生效的结果 3. 相关连接 本示例完整代码 码云 Github]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试-计算机网络常见问题]]></title>
    <url>%2F2018%2F07%2F17%2F%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【转载】-Java面试中常见的计算机网络方面问题-（部分增加修改） 1. GET 和 POST 的区别GET方法（GET）请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST方法（POST）请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 2. DNS使用的协议既使用TCP又使用UDP 首先了解一下TCP与UDP传送字节的长度限制： UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 区域传送时使用TCP，主要有一下两点考虑： 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 3. 幂等 一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername() 和 setTrue()” 函数就是一个幂等函数. 3. Cookies 和 session 区别 Cookies 是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。Cookies 是当你浏览某网站时，由 Web 服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户 ID、密码、浏览过的网页、停留的时间等信息。session: 当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。cookie 机制：采用的是在客户端保持状态的方案，而 session 机制采用的是在服务端保持状态的方案。同时我们看到由于服务器端保持状态的方案在客户端也需要保存一个标识，所以 session 机制可能需要借助 cookie 机制来达到保存标识的目的。 Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：session ID。当服务器创建了 Session 时，给客户端发送的响应报文包含了 Set-cookie 字段，其中有一个名为 sid 的键值对，这个键值 Session ID。客户端收到后就把 Cookie 保存浏览器，并且之后发送的请求报表都包含 SessionID。HTTP 就是通过 Session 和 Cookie 这两个发送一起合作来实现跟踪用户状态，Session 用于服务端，Cookie 用于客户端 4. TCP 粘包和拆包产生的原因 应用程序写入数据的字节大小大于套接字发送缓冲区的大小 进行 MSS 大小的 TCP 分段。MSS 是最大报文段长度的缩写。MSS 是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是 TCP 报文段的最大长度，而是：MSS=TCP 报文段长度 - TCP 首部长度 以太网的 payload 大于 MTU 进行 IP 分片。MTU 指：一种通信协议的某一层上面所能通过的最大数据包大小。如果 IP 层有一个数据包要传，而且数据的长度比链路层的 MTU 大，那么 IP 层就会进行分片，把数据包分成托干片，让每一片都不超过 MTU。注意，IP 分片可以发生在原始发送端主机上，也可以发生在中间路由器上。 5. TCP 粘包和拆包的解决策略 消息定长。例如 100 字节。 在包尾部增加回车或者空格符等特殊字符进行分割，典型的如 FTP 协议 将消息分为消息头和消息尾。 其它复杂的协议，如 RTMP 协议等 6. 三次握手 第一次握手：建立连接时，客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认； 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据 7. 四次挥手 客户端先发送 FIN，进入 FIN_WAIT1 状态 服务端收到 FIN，发送 ACK，进入 CLOSE_WAIT 状态，客户端收到这个 ACK，进入 FIN_WAIT2 状态 服务端发送 FIN，进入 LAST_ACK 状态 客户端收到 FIN，发送 ACK，进入 TIME_WAIT 状态，服务端收到 ACK，进入 CLOSE 状态TIME_WAIT 的状态就是主动断开的一方（这里是客户端），发送完最后一次 ACK 之后进入的状态。并且持续时间还挺长的。客户端 TIME_WAIT 持续 2 倍 MSL 时长，在 linux 体系中大概是 60s，转换成 CLOSE 状态 TIME_WAITTIME_WAIT 是主动关闭链接时形成的，等待 2MSL 时间，约 4 分钟。主要是防止最后一个 ACK 丢失。 由于 TIME_WAIT 的时间会非常长，因此 server 端应尽量减少主动关闭连接 CLOSE_WAITCLOSE_WAIT 是被动关闭连接是形成的。根据 TCP 状态机，服务器端收到客户端发送的 FIN，则按照 TCP 实现发送 ACK，因此进入 CLOSE_WAIT 状态。但如果服务器端不执行 close()，就不能由 CLOSE_WAIT 迁移到 LAST_ACK，则系统中会存在很多 CLOSE_WAIT 状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到 FIN 的连接，进行 close。此时，recv/read 已收到 FIN 的连接 socket，会返回 0。 为什么需要 TIME_WAIT 状态？假设最终的 ACK 丢失，server 将重发 FIN，client 必须维护 TCP 状态信息以便可以重发最终的 ACK，否则会发送 RST，结果 server 认为发生错误。TCP 实现必须可靠地终止连接的两个方向 (全双工关闭)，client 必须进入 TIME_WAIT 状态，因为 client 可能面 临重发最终 ACK 的情形。 为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？如果 TIME_WAIT 状态保持时间不足够长 (比如小于 2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP 实现必须防止某个连接的重复报文在连接终止后出现，所以让 TIME_WAIT 状态保持时间足够长 (2MSL)，连接相应方向上的 TCP 报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。 TIME_WAIT 和 CLOSE_WAIT 状态 socket 过多如果服务器出了异常，百分之八九十都是下面两种情况：1. 服务器保持了大量 TIME_WAIT 状态2. 服务器保持了大量 CLOSE_WAIT 状态，简单来说 CLOSE_WAIT 数目过大是由于被动关闭连接处理不当导致的。 8. 一次完整的 HTTP 请求过程域名解析 –&gt; 发起 TCP 的 3 次握手 –&gt; 建立 TCP 连接后发起 http 请求 –&gt; 服务器响应 http 请求，浏览器得到 html 代码 –&gt; 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 9. 讲一下长连接一、基于 http 协议的长连接 在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持. http1.0 请求与服务端的交互过程: 客户端发出带有包含一个 header：”Connection： keep-alive“的请求 服务端接收到这个请求后, 根据 http1.0 和”Connection： keep-alive“判断出这是一个长连接, 就会在 response 的 header 中也增加”Connection： keep-alive“, 同是不会关闭已建立的 tcp 连接. 客户端收到服务端的 response 后, 发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送 request. 转到 a)二、发心跳包。每隔几秒就发一个数据包过去 10. TCP 如何保证可靠传输？ 三次握手。 将数据截断为合理的长度。应用数据被分割成 TCP 认为最适合发送的数据块（按字节编号，合理分片） 超时重发。当 TCP 发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发 对于收到的请求，给出确认响应 校验出包有错，丢弃报文段，不给出响应 对失序数据进行重新排序，然后才交给应用层 对于重复数据 ， 能够丢弃重复数据 流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。 拥塞控制。当网络拥塞时，减少数据的发送。 11. 详细介绍 http HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写, 是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 特点 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持 B/S 及 C/S 模式。请求消息 Request 请求行，用来说明请求类型, 要访问的资源以及所使用的 HTTP 版本. 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST 将指出请求的目的地. User-Agent, 服务器端和客户端脚本都能访问它, 它是浏览器类型检测逻辑的重要基础. 该信息由你的浏览器来定义, 并且在每个请求中自动发送等等 空行，请求头部后面的空行是必须的 请求数据也叫主体，可以添加任意的其他数据。响应消息 Response 状态行，由 HTTP 协议版本号， 状态码， 状态消息 三部分组成。 消息报头，用来说明客户端要使用的一些附加信息 空行，消息报头后面的空行是必须的 响应正文，服务器返回给客户端的文本信息。状态码 200 OK // 客户端请求成功 301 Moved Permanently // 永久重定向, 使用域名跳转 302 Found // 临时重定向, 未登陆的用户访问用户中心重定向到登录页面 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden // 服务器收到请求，但是拒绝提供服务 404 Not Found // 请求资源不存在，eg：输入了错误的 URL 500 Internal Server Error // 服务器发生不可预期的错误 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常http 的方法 get: 客户端向服务端发起请求，获得资源。请求获得 URL 处所在的资源。 post: 向服务端提交新的请求字段。请求 URL 的资源后添加新的数据。 head: 请求获取 URL 资源的响应报告，即获得 URL 资源的头部 patch：请求局部修改 URL 所在资源的数据项 put：请求修改 URL 所在资源的数据元素。 delete：请求删除 url 资源的数据 12. URI 和 URL 的区别 URI，是 uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web 上可用的每种资源如 HTML 文档、图像、视频片段、程序等都是一个来 URI 来定位的 URI 一般由三部组成： 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。URL 是 uniform resource locator，统一资源定位器，它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上，特别是著名的 Mosaic。采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL 一般由三部组成： 协议 (或称为服务方式) 存有该资源的主机 IP 地址 (有时也包括端口号) 主机资源的具体地址。如目录和文件名等 13. HTTPS 和 HTTP 的区别 https 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 http 是超文本传输协议，信息是明文传输；https 则是具有安全性的 ssl 加密传输协 议。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 http 默认使用 80 端口，https 默认使用 443 端口 14. HTTPS 是如何保证数据传输的安全 https 实际就是在 TCP 层与 http 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。 SSL/TLS 协议作用： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。]]></content>
      <categories>
        <category>面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-控制并发线程数的Semaphore]]></title>
    <url>%2F2018%2F07%2F17%2FJava%E5%B9%B6%E5%8F%91-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84Semaphore%2F</url>
    <content type="text"><![CDATA[【转载】-本文摘自《Java并发编程的艺术-方腾飞》（少许更正修改） &nbsp;&nbsp;Semaphore(信号量)用来龙之同时访问特定资源的线程数量，它通过协调各个线程，以保证合理使用公共资源 &nbsp;&nbsp; 多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯。比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶人马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。 1. 应用场景&nbsp;&nbsp;Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如代码所示。 1234567891011121314151617181920212223public class SemophoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT); //新建线程池 private static Semaphore s= new Semaphore(10); //最多10个线程获得许可证 public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(()-&gt;&#123; try &#123; s.acquire(); //获取一个许可证 System.out.println("save data"); s.release(); //释放一个许可证 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore(int permits)接受一个整型的数字，表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。 2. 其他方法Semaphore还提供一些其他方法： int availablePermits() ：返回此信号量中当前可用的许可证数。 int getQueueLength()：返回正在等待获取许可证的线程数。 boolean hasQueuedThreads() ：是否有线程正在等待获取许可证。 void reducePermits(int reduction) ：减少reduction个许可证。是个protected方法。 Collection getQueuedThreads() ：返回所有等待获取许可证的线程集合。是个protected方法 其他链接 完整代码-Github 并发编程网-ifeve-控制并发线程数量的Semaphore]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Semaphore</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-等待多线程完成的CountDownLatch]]></title>
    <url>%2F2018%2F07%2F16%2FJava%E5%B9%B6%E5%8F%91-%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E7%9A%84CountDownLatch%2F</url>
    <content type="text"><![CDATA[【转载】-本文摘自《Java并发编程的艺术-方腾飞》 CountDownLatch允许一个或多个线程等待其他线程完成操作。假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join()方法，如下所示。 123456789101112131415public class JoinCountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread parser1 = new Thread(()-&gt; System.out.println("parser1 finish")); Thread parser2 = new Thread(() -&gt; System.out.println("parser2 finish")); parser1.start(); parser2.start(); parser1.join(); parser2.join(); System.out.println("all parser finish"); &#125;&#125; join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中，wait(0)表示永远等待下去，代码片段如下: 123while(isAlive)&#123; wait(0);&#125; 直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里实现的，所以在JDK里看不到，大家可以查看JVM源码 在JDK l.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多，如代码清单所示 123456789101112131415public class CountDownLatchTest &#123; static CountDownLatch c = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; System.out.println(1); c.countDown(); System.out.println(2); c.countDown(); &#125;).start(); c.await(); System.out.println("3"); &#125;&#125; &nbsp;&nbsp;CountDownLacth的构造函数接受一个int类型的参数作为计数器,如果你想等待N个点完成,这里传入N&nbsp;&nbsp;当我们调用CountDownLacth的countDown方法时,N就会减1,CountDownLatch的await方法会阻塞当前线程,直到N变成0&nbsp;&nbsp;由于countDown方法可以用在任何其他地方,所以这里说的n个点,可以是N个线程,也可以是一个线程里面的N个步骤,用在多线程时,只需要把这个CountDownLatch的引用传递到线程里即可&nbsp;&nbsp;如果一个线程执行过慢,还可以使用另外一个带指定时间的await方法,await(long time,TimeUint unit) 更多CountDownLatch的应用示例，可参考文末的完整代码链接 相关连接 Github-完整代码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>转载</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-同步屏障CyclicBarrier]]></title>
    <url>%2F2018%2F07%2F16%2FJava%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9CCyclicBarrier%2F</url>
    <content type="text"><![CDATA[【转载】- 本文内容摘自《Java并发编程的艺术-方腾飞》 CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 1. CyclicBarrier简介CyclicBarrier默认的构造方法是CyclicBarrier( int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 示例代码 CyclicBarrierTest.java 123456789101112131415161718192021222324252627public class CyclicBarrierTest &#123; /** * CyclicBarrier同步屏障 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞， * 直到最后一个线程到达屏障时，屏障才会开门，所有别屏蔽的线程才会继续运行 */ static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(1); &#125;).start(); try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125;&#125; 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出，第一种可能输出如下: 1234512#或者21 CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties，Runnable barrier-Action)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如下所示。 示例代码:CyclicBarrierTest2.java 1234567891011121314151617181920212223242526272829public class CyclicBarrierTest2 &#123; static CyclicBarrier c = new CyclicBarrier(2, new A()); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(1); &#125;).start(); try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125; static class A implements Runnable &#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; 因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出如下。 123312 2. CyclicBarrier的应用场景CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，如下所示 BankWaterService.java 代码过长,完整见文末连接 3. CyclicBarrier和CountDownLatch的区别CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset0方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken0方法用来了解阻塞的线程是否被中断。代码清单8-5执行完之后会返回true，其中isBroken的使用代码如代码所示 12345678910111213141516171819public class CyclicBarrierTest3 &#123; static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args)&#123; Thread thread = new Thread(() -&gt; &#123; try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; &#125;); thread.start(); thread.interrupt(); //中断thread try &#123; c.await(); &#125; catch (Exception e) &#123; System.out.println(c.isBroken()); &#125; &#125;&#125; 运行结果: 1true 相关连接 完整代码-github]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>转载</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构系列-负载均衡详解]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[【转载】大型网站架构系列-负载均衡详解 &ensp; &ensp; 面对大量用户访问、高并发请求，海量数据，可以使用高性能的服务器、大型数据库，存储设备，高性能Web服务器，采用高效率的编程语言比如(Go,Scala)等，当单机容量达到极限时，我们需要考虑业务拆分和分布式部署，来解决大型网站访问量大，并发量高，海量数据的问题 &ensp; &ensp; 从单机网站到分布式网站，很重要的区别是业务拆分和分布式部署，将应用拆分后，部署到不同的机器上，实现大规模分布式系统。分布式和业务拆分解决了，从集中到分布的问题，但是每个部署的独立业务还存在单点的问题和访问统一入口问题，为解决单点故障，我们可以采取冗余的方式。将相同的应用部署到多台机器上。解决访问统一入口问题，我们可以在集群前面增加负载均衡设备，实现流量分发 负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案 1. 负载均衡的原理&ensp;&ensp;系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图 应用集群:将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据 负载均衡设备:将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备） 负载均衡的作用(解决的问题) 解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力） 提供故障转移，实现高可用； 通过添加或减少服务器数量，提供网站伸缩性（扩展性）； 安全防护（负载均衡设备上做一些过滤，黑白名单等处理） 2. 负载均衡分类根据实现技术不同,可分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等。 2.1 DNS负载均衡最早的负载均衡技术，利用域名解析实现负载均衡，在DNS服务器，配置多个A记录，这些A记录对应的服务器构成集群。大型网站总是部分使用DNS解析，作为第一级负载均衡。如下图： 优点 使用简单：负载均衡工作，交给DNS服务器处理，省掉了负载均衡服务器维护的麻烦 提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能 缺点 可用性差：DNS解析是多级解析，新增/修改DNS后，解析时间较长；解析过程中，用户访问网站将失败； 扩展性低：DNS负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展； 维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载） 实践建议 将DNS作为第一级负载均衡，A记录对应着内部负载均衡的IP地址，通过内部负载均衡将请求分发到真实的Web服务器上。一般用于互联网公司，复杂的业务系统不合适使用。如下图 2.2 IP负载均衡在网络层通过修改请求目标地址进行负载均衡。 用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实ip地址，不需要经过用户进程处理。 真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的ip地址，发送给用户浏览器。如下图： IP负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式： 负载均衡服务器在修改目的ip地址的同时修改源地址。将数据包源地址设为自身盘，即源地址转换（snat）。 将负载均衡服务器同时作为真实物理服务器集群的网关服务器 优点 在内核进程完成数据分发,比在应用层分发性能更好; 缺点 所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽； 2.3 链路层负载均衡在通信协议的数据链路层修改mac地址，进行负载均衡 数据分发时，不修改ip地址，指修改目标mac地址，配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的 实际处理服务器ip和数据请求目的ip一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR模式）。如下图 优点:性能好 缺点:配置复杂； 实践建议：DR模式是目前使用最广泛的一种负载均衡方式 2.4 混合型负载均衡由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡 此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。 方式一，如下图： 以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。 方式二,如下图: 以上模式，适合动态请求场景。因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。 3. 负载均衡算法常用的负载均衡算法有，轮询，随机，最少链接，源地址散列，加权等方式； 3.1 轮询将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。优点：服务器请求数目相同；缺点：服务器压力不一样，不适合服务器配置不同的情况； 3.2 随机请求随机分配到各个服务器。优点：使用简单；缺点：不适合机器配置不同的场景； 3.3 最少链接将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。优点：根据服务器当前的请求处理情况，动态分配；缺点：算法实现相对复杂，需要监控服务器请求连接数； 3.4 Hash（源地址散列）根据IP地址进行Hash计算，得到IP地址。优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。缺点：目标服务器宕机后，会话会丢失； 3.5 加权在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。优点：根据权重，调节转发服务器的请求数目；缺点: 使用相对复杂 4、硬件负载均衡采用硬件的方式实现负载均衡，一般是单独的负载均衡服务器，价格昂贵，一般土豪级公司可以考虑，业界领先的有两款，F5和A10。使用硬件负载均衡，主要考虑一下几个方面： 功能考虑：功能全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡； 性能考虑：一般软件负载均衡支持到5万级并发已经很困难了，硬件负载均衡可以支持 稳定性：商用硬件负载均衡，经过了良好的严格的测试，从经过大规模使用，在稳定性方面高； 安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙，防DDOS攻击等安全功能； 维护角度：提供良好的维护管理界面，售后服务和技术支持； 土豪公司：F5 Big Ip 价格：15w~55w不等；A10 价格：55w-100w不等； 缺点（1）价格昂贵；（2）扩展能力差 5. 总结 一般硬件的负载均衡也要做双机高可用，因此成本会比较高。 互联网公司一般使用开源软件，因此大部分应用采用软件负载均衡；部分采用硬件负载均衡。 比如某互联网公司，目前是使用几台F5做全局负载均衡，内部使用Nginx等软件负载均衡]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-深入理解Java类型（Class对象）与反射机制]]></title>
    <url>%2F2018%2F07%2F09%2FJava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%9E%8B%EF%BC%88Class%E5%AF%B9%E8%B1%A1%EF%BC%89%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[【转载】深入理解Java类型信息(Class对象)与反射机制-原文连接 1. 深入理解Class对象1.1 RRTI的概念以及Class对象引用认识Class对象之前，先来了解一个概念，RTTI（Run-Time Type Identification）运行时类型识别，对于这个词一直是 C++ 中的概念，至于Java中出现RRTI的说法则是源于《Thinking in Java》一书，其作用是在运行时识别一个对象的类型和类的信息，这里分两种：传统的”RRTI”,它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中，其部分源码如下： 1234567891011121314151617181920public final class Class&lt;T&gt; implements java.io.Serializable,GenericDeclaration,Type, AnnotatedElement &#123; private static final int ANNOTATION= 0x00002000; private static final int ENUM = 0x00004000; private static final int SYNTHETIC = 0x00001000; private static native void registerNatives(); static &#123; registerNatives(); &#125; /* * Private constructor. Only the Java Virtual Machine creates Class objects.（私有构造，只能由JVM创建该类） * This constructor is not used and prevents the default constructor being * generated. */ private Class(ClassLoader loader) &#123; // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; &#125; Class类被创建后的对象就是Class对象，注意，Class对象表示的是自己手动编写类的类型信息，比如创建一个Shapes类，那么，JVM就会创建一个Shapes对应Class类的Class对象，该Class对象保存了Shapes类相关的类型信息。实际上在Java中每个类都有一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象并且这个Class对象会被保存在同名.class文件里(编译后的字节码文件保存的就是Class对象)，那为什么需要这样一个Class对象呢？是这样的，当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。需要特别注意的是，手动编写的每个class类，无论创建多少个实例对象，在JVM中都只有一个Class对象，即在内存中每个类有且只有一个相对应的Class对象，挺拗口，通过下图理解（内存中的简易现象图）： 1.2 总结信息到这我们也就可以得出以下几点信息： Class类也是类的一种，与class关键字是不一样的。 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。 Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载 Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。 2. Class对象的加载及其获取方法2.1 Class对象的加载前面我们已提到过，Class对象是由JVM加载的，那么其加载时机是？实际上所有的类都是在对其第一次使用时动态加载到JVM中的，当程序创建第一个对类的静态成员引用时，就会加载这个被使用的类(实际上加载的就是这个类的字节码文件)，注意，使用new操作符创建类的新实例对象也会被当作对类的静态成员的引用(构造函数也是类的静态方法)，由此看来Java程序在它们开始运行之前并非被完全加载到内存的，其各个部分是按需加载，所以在使用该类时，类加载器首先会检查这个类的Class对象是否已被加载(类的实例对象创建时依据Class对象中类型信息完成的)，如果还没有加载，默认的类加载器就会先根据类名查找.class文件(编译后Class对象被保存在同名的.class文件中)，在这个类的字节码文件被加载时，它们必须接受相关验证，以确保其没有被破坏并且不包含不良Java代码(这是java的安全机制检测)，完全没有问题后就会被动态加载到内存中，此时相当于Class对象也就被载入内存了(毕竟.class字节码文件保存的就是Class对象)，同时也就可以被用来创建这个类的所有实例对象。下面通过一个简单例子来说明Class对象被加载的时机问题（例子引用自Thinking in Java）： 123456789101112131415161718192021222324252627282930class Candy &#123; static &#123; System.out.println("Loading Candy"); &#125;&#125; class Gum &#123; static &#123; System.out.println("Loading Gum"); &#125;&#125; class Cookie &#123; static &#123; System.out.println("Loading Cookie"); &#125;&#125; public class SweetShop &#123; public static void print(Object obj) &#123; System.out.println(obj); &#125; public static void main(String[] args) &#123; print("inside main"); new Candy(); print("After creating Candy"); try &#123; Class.forName("com.zejian.Gum"); &#125; catch(ClassNotFoundException e) &#123; print("Couldn't find Gum"); &#125; print("After Class.forName(\"com.zejian.Gum\")"); new Cookie(); print("After creating Cookie"); &#125;&#125; 在上述代码中,每个类Candy、Gum、Cookie都存在一个static语句，这个语句会在类第一次被加载时执行，这个语句的作用就是告诉我们该类在什么时候被加载，执行结果 : 123456789inside mainLoading CandyAfter creating CandyLoading GumAfter Class.forName("com.zejian.Gum")Loading CookieAfter creating Cookie Process finished with exit code 0 从结果来看，new一个Candy对象和Cookie对象，构造函数将被调用，属于静态方法的引用，Candy类的Class对象和Cookie的Class对象肯定会被加载，毕竟Candy实例对象的创建依据其Class对象。比较有意思的是 1Class.forName("reflect.Gum"); 其中forName方法是Class类的一个static成员方法，记住所有的Class对象都源于这个Class类，因此Class类中定义的方法将适应所有Class对象。这里通过forName方法，我们可以获取到Gum类对应的Class对象引用。从打印结果来看，调用forName方法将会导致Gum类被加载(前提是Gum类从来没有被加载过) 2.2 Class.forName方法通过上述的案例，我们也就知道Class.forName()方法的调用将会返回一个对应类的Class对象，因此如果我们想获取一个类的运行时类型信息并加以使用时，可以调用Class.forName()方法获取Class对象的引用，这样做的好处是无需通过持有该类的实例对象引用而去获取Class对象，如下的第2种方式是通过一个实例对象获取一个类的Class对象，其中的getClass()是从顶级类Object继承而来的，它将返回表示该对象的实际类型的Class对象引用。 12345678910111213141516public static void main(String[] args) &#123; try&#123; //通过Class.forName获取Gum类的Class对象 Class clazz=Class.forName("com.zejian.Gum"); System.out.println("forName=clazz:"+clazz.getName()); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; //通过实例对象获取Gum的Class对象 Gum gum = new Gum(); Class clazz2=gum.getClass(); System.out.println("new=clazz2:"+clazz2.getName()); &#125; 注意调用forName方法时需要捕获一个名称为ClassNotFoundException的异常，因为forName方法在编译器是无法检测到其传递的字符串对应的类是否存在的，只能在程序运行时进行检查，如果不存在就会抛出ClassNotFoundException异常。 2.3 Class字面常量在Java中存在另一种方式来生成Class对象的引用，它就是Class字面常量，如下： 12//字面常量的方式获取Class对象Class clazz = Gum.class; 这种方式相对前面两种方法更加简单，更安全。因为它在编译器就会受到编译器的检查同时由于无需调用forName方法效率也会更高，因为通过字面量的方法获取Class对象的引用不会自动初始化该类。更加有趣的是字面常量的获取Class对象引用方式不仅可以应用于普通的类，也可以应用用接口，数组以及基本数据类型，这点在反射技术应用传递参数时很有帮助，关于反射技术稍后会分析，由于基本数据类型还有对应的基本包装类型，其包装类型有一个标准字段TYPE，而这个TYPE就是一个引用，指向基本数据类型的Class对象，其等价转换如下，一般情况下更倾向使用.class的形式，这样可以保持与普通类的形式统一。 123456789boolean.class = Boolean.TYPE;char.class = Character.TYPE;byte.class = Byte.TYPE;short.class = Short.TYPE;int.class = Integer.TYPE;long.class = Long.TYPE;float.class = Float.TYPE;double.class = Double.TYPE;void.class = Void.TYPE; 前面提到过，使用字面常量的方式获取Class对象的引用不会触发类的初始化，这里我们可能需要简单了解一下类加载的过程，如下： 加载：类加载过程的第一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个 Class对象 连接：验证字节码的安全性和完整性，准备阶段正式为静态域分配存储空间，注意此时只是分配静态成员变量的存储空间，不包含实例成员变量，如果必要的话，解析这个类创建的对其他类的所有引用 初始化 :类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量 由此可知，我们获取字面常量的Class引用时，触发的应该是加载阶段，因为在这个阶段Class对象已创建完成，获取其引用并不困难，而无需触发类的最后阶段初始化。下面通过小例子来验证这个过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Initable&#123; //编译器静态变量 static final int staticFianl = 47; //非编译期静态常量 static final int staticFinal2 = ClassInitialization.rand.nextInt(1000); static &#123; System.out.println("Initializing Initable"); &#125;&#125; class Initable2&#123; //静态成员变量 static int staicNonFinal = 147; static &#123; System.out.println("Initializing Initable2"); &#125;&#125; class Initable3&#123; static int staticNonFinal = 74; static &#123; System.out.println("Initializing Initable3"); &#125;&#125; public class ClassInitialization &#123; public static Random rand = new Random(47); public static void main(String[] args) throws ClassNotFoundException &#123; //字面常量获取方式获取Class对象 Class initable = Initable.class; System.out.println("After createing Initable ref"); //不触发类初始化 System.out.println("1:"+Initable.staticFianl); //会触发类初始化 System.out.println("1:"+Initable.staticFinal2); //会触发类的初始化 System.out.println("2:"+Initable2.staicNonFinal); //forName方法获取Class对象 Class initable3 = Class.forName("reflect.csdn.Initable3"); System.out.println("After createing Initable3 ref"); System.out.println("3:"+Initable3.staticNonFinal); &#125;&#125; 运行结果： 1234567891011After createing Initable ref1:47Initializing Initable1:258Initializing Initable22:147Initializing Initable3After createing Initable3 ref3:74 Process finished with exit code 0 从输出结果来看，可以发现，通过字面常量获取方式获取Initable类的Class对象并没有触发Initable类的初始化，这点也验证了前面的分析，同时发现调用Initable.staticFinal变量时也没有触发初始化，这是因为staticFinal属于编译期静态常量，在编译阶段通过常量传播优化的方式将Initable类的常量staticFinal存储到了一个称为NotInitialization类的常量池中，在以后对Initable类常量staticFinal的引用实际都转化为对NotInitialization类对自身常量池的引用，所以在编译期后，对编译期常量的引用都将在NotInitialization类的常量池获取，这也就是引用编译期静态常量不会触发Initable类初始化的重要原因。但在之后调用了Initable.staticFinal2变量后就触发了Initable类的初始化，注意staticFinal2虽然被static和final修饰，但其值在编译期并不能确定，因此staticFinal2并不是编译期常量，使用该变量必须先初始化Initable类。Initable2和Initable3类中都是静态成员变量并非编译期常量，引用都会触发初始化。至于forName方法获取Class对象，肯定会触发初始化，这点在前面已分析过。到这几种获取Class对象的方式也都分析完，ok~,到此这里可以得出小结论： 获取Class对象引用的方式3种，通过继承自Object类的getClass方法，Class类的静态方法forName以及字面常量的方式.class。 其中实例类的getClass方法和Class类的静态方法forName都将会触发类的初始化阶段，而字面常量获取Class对象的方式则不会触发初始化。 初始化是类加载的最后一个阶段，也就是说完成这个阶段后类也就加载到内存中(Class对象在加载阶段已被创建)，此时可以对类进行各种必要的操作了（如new对象，调用静态成员等），注意在这个阶段，才真正开始执行类中定义的Java程序代码或者字节码 关于类加载的初始化阶段，在虚拟机规范严格规定了有且只有5种场景必须对类进行初始化 使用new关键字实例化对象时、读取或者设置一个类的静态字段(不包含编译期常量)以及调用静态方法的时候，必须触发类加载的初始化过程(类加载过程最终阶段) 使用反射包(java.lang.reflect)的方法对类进行反射调用时，如果类还没有被初始化，则需先进行初始化，这点对反射很重要。 当初始化一个类的时候，如果其父类还没进行初始化则需先触发其父类的初始化 当Java虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的类)，虚拟机会先初始化这个主类 当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，必须触发其初始化(这点看不懂就算了，这是1.7的新增的动态语言支持，其关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，这是一个比较大点的话题，这里暂且打住) 2.4 理解泛化的Class对象引用由于Class的引用总数指向某个类的Class对象，利用Class对象可以创建实例类，这也就足以说明Class对象的引用指向的对象确切的类型。在Java SE5引入泛型后，使用我们可以利用泛型来表示Class对象更具体的类型，即使在运行期间会被擦除，但编译期足以确保我们使用正确的对象类型。如下: 12345678910111213141516171819202122/*** Created by zejian on 2017/4/30.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]*/public class ClazzDemo &#123; public static void main(String[] args)&#123; //没有泛型 Class intClass = int.class; //带泛型的Class对象 Class&lt;Integer&gt; integerClass = int.class; integerClass = Integer.class; //没有泛型的约束,可以随意赋值 intClass= double.class; //编译期错误,无法编译通过 //integerClass = double.class &#125;&#125; 从代码可以看出，声明普通的Class对象，在编译器并不会检查Class对象的确切类型是否符合要求，如果存在错误只有在运行时才得以暴露出来。但是通过泛型声明指明类型的Class对象，编译器在编译期将对带泛型的类进行额外的类型检查，确保在编译期就能保证类型的正确性，实际上Integer.class就是一个Class&lt;Integer&gt;类的对象。面对下述语句，确实可能令人困惑，但该语句确实是无法编译通过的。 12//编译无法通过Class&lt;Number&gt; numberClass=Integer.class; 我们或许会想Integer不就是Number的子类吗？然而事实并非这般简单，毕竟Integer的Class对象并非Number的Class对象的子类，前面提到过，所有的Class对象都只来源于Class类，看来事实确实如此。当然我们可以利用通配符“?”来解决问题： 12Class&lt;?&gt; intClass = int.class;intClass = double.class; 这样的语句并没有什么问题，毕竟通配符指明所有类型都适用，那么为什么不直接使用Class还要使用Class&lt;?&gt;呢？这样做的好处是告诉编译器，我们是确实是采用任意类型的泛型，而非忘记使用泛型约束，因此Class&lt;?&gt;总是优于直接使用Class，至少前者在编译器检查时不会产生警告信息。当然我们还可以使用extends关键字告诉编译器接收某个类型的子类，如解决前面Number与Integer的问题： 12345//编译通过！Class&lt;? extends Number&gt; clazz = Integer.class;//赋予其他类型clazz = double.class;clazz = Number.class; 上述的代码是行得通的，extends关键字的作用是告诉编译器，只要是Number的子类都可以赋值。这点与前面直接使用Class&lt;Number&gt;是不一样的。实际上，应该时刻记住向Class引用添加泛型约束仅仅是为了提供编译期类型的检查从而避免将错误延续到运行时期。 2.5 关于类型转换的问题在许多需要强制类型转换的场景，我们更多的做法是直接强制转换类型： 12345678910111213public class ClassCast &#123; public void cast()&#123; Animal animal= new Dog(); //强制转换 Dog dog = (Dog) animal;&#125;&#125; interface Animal&#123; &#125; class Dog implements Animal&#123; &#125; 之所可以强制转换，这得归功于RRTI，要知道在Java中，所有类型转换都是在运行时进行正确性检查的，利用RRTI进行判断类型是否正确从而确保强制转换的完成，如果类型转换失败，将会抛出类型转换异常。除了强制转换外，在Java SE5中新增一种使用Class对象进行类型转换的方式，如下： 1234Animal animal= new Dog();//这两句等同于Dog dog = (Dog) animal;Class&lt;Dog&gt; dogType = Dog.class;Dog dog = dogType.cast(animal) 利用Class对象的cast方法，其参数接收一个参数对象并将其转换为Class引用的类型。这种方式似乎比之前的强制转换更麻烦些，确实如此，而且当类型不能正确转换时，仍然会抛出ClassCastException异常。源码如下 12345public T cast(Object obj) &#123; if (obj != null &amp;&amp; !isInstance(obj)) throw new ClassCastException(cannotCastMsg(obj)); return (T) obj; &#125; 2.5 instanceof 关键字与 isInstance()方法关于instanceof 关键字，它返回一个boolean类型的值，意在告诉我们对象是不是某个特定的类型实例。如下，在强制转换前利用instanceof检测obj是不是Animal类型的实例对象，如果返回true再进行类型转换，这样可以避免抛出类型转换的异常(ClassCastException) 12345public void cast2(Object obj)&#123; if(obj instanceof Animal)&#123; Animal animal= (Animal) obj; &#125;&#125; 而isInstance()方法则是Class类中的一个Native方法，也是用于判断对象类型的，看个简单例子： 1234567891011public void cast2(Object obj)&#123; //instanceof关键字 if(obj instanceof Animal)&#123; Animal animal= (Animal) obj; &#125; //isInstance方法 if(Animal.class.isInstance(obj))&#123; Animal animal= (Animal) obj; &#125; &#125; 事实上instanceOf 与isInstance()方法产生的结果是相同的。对于instanceOf是关键字只被用于对象引用变量，检查左边对象是不是右边类或接口的实例化。如果被测对象是null值，则测试结果总是false。一般形式： 12//判断这个对象是不是这种类型obj.instanceof(class) 而isInstance()方法则是Class类的Native方法，其中obj是被测试的对象或者变量，如果obj是调用这个方法的class或接口的实例，则返回true。如果被检测的对象是null或者基本类型，那么返回值是false;一般形式如下 12//判断这个对象能不能被转化为这个类class.inInstance(obj) 最后这里给出一个简单实例，验证isInstance方法与instanceof等价性： 12345678910111213141516171819202122232425262728class A &#123;&#125; class B extends A &#123;&#125; public class C &#123; static void test(Object x) &#123; System.out.println("Testing x of type " + x.getClass()); System.out.println("x instanceof A " + (x instanceof A)); System.out.println("x instanceof B "+ (x instanceof B)); System.out.println("A.isInstance(x) "+ A.class.isInstance(x)); System.out.println("B.isInstance(x) " + B.class.isInstance(x)); System.out.println("x.getClass() == A.class " + (x.getClass() == A.class)); System.out.println("x.getClass() == B.class " + (x.getClass() == B.class)); System.out.println("x.getClass().equals(A.class)) "+ (x.getClass().equals(A.class))); System.out.println("x.getClass().equals(B.class)) " + (x.getClass().equals(B.class))); &#125; public static void main(String[] args) &#123; test(new A()); test(new B()); &#125; &#125; 运行结果: 1234567891011121314151617181920Testing x of type class reflect.csdn.Ax instanceof A truex instanceof B falseA.isInstance(x) trueB.isInstance(x) falsex.getClass() == A.class truex.getClass() == B.class falsex.getClass().equals(A.class)) truex.getClass().equals(B.class)) falseTesting x of type class reflect.csdn.Bx instanceof A truex instanceof B trueA.isInstance(x) trueB.isInstance(x) truex.getClass() == A.class falsex.getClass() == B.class truex.getClass().equals(A.class)) falsex.getClass().equals(B.class)) true Process finished with exit code 0 到此关于Class对象相关的知识点都分析完了，下面将结合Class对象的知识点分析反射技术。 3. 理解反射技术反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。一直以来反射技术都是Java中的闪亮点，这也是目前大部分框架(如Spring/Mybatis等)得以实现的支柱。在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。 3.1 Constructor类及其用法Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下： 方法返回值 方法名称 方法说明 static Class&lt;?&gt; forName(String className) 返回与带有给定字符串名的类或接口相关联的 Class 对象。 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 返回指定参数类型、具有public访问权限的构造函数对象 Constructor&lt;?&gt;[] getConstructors() 返回所有具有public访问权限的构造函数的Constructor对象数组 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 返回指定参数类型、所有声明的（包括private）构造函数对象 Constructor&lt;?&gt;[] getDeclaredConstructor() 返回所有声明的（包括private）构造函数对象 T newInstance() 创建此 Class 对象所表示的类的一个新实例。 下面看一个简单例子来了解Constructor对象的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package reflect; import java.io.Serializable;import java.lang.reflect.Constructor; /*** Created by zejian on 2017/5/1.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]*/public class ReflectDemo implements Serializable&#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = null; //获取Class对象的引用 clazz = Class.forName("reflect.User"); //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常 User user = (User) clazz.newInstance(); user.setAge(20); user.setName("Rollen"); System.out.println(user); System.out.println("--------------------------------------------"); //获取带String参数的public构造函数 Constructor cs1 =clazz.getConstructor(String.class); //创建User User user1= (User) cs1.newInstance("xiaolong"); user1.setAge(22); System.out.println("user1:"+user1.toString()); System.out.println("--------------------------------------------"); //取得指定带int和String参数构造函数,该方法是私有构造private Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class); //由于是private必须设置可访问 cs2.setAccessible(true); //创建user对象 User user2= (User) cs2.newInstance(25,"lidakang"); System.out.println("user2:"+user2.toString()); System.out.println("--------------------------------------------"); //获取所有构造包含private Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; //获取构造函数参数类型 Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); System.out.println("构造函数["+i+"]:"+cons[i].toString() ); System.out.print("参数类型["+i+"]:("); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + ","); &#125; System.out.println(")"); &#125; &#125;&#125; class User &#123; private int age; private String name; public User() &#123; super(); &#125; public User(String name) &#123; super(); this.name = name; &#125; /** * 私有构造 * @param age * @param name */ private User(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; //..........省略set 和 get方法&#125; 运行结果： 123456789101112User [age=20, name=Rollen]--------------------------------------------user1:User [age=22, name=xiaolong]--------------------------------------------user2:User [age=25, name=lidakang]--------------------------------------------构造函数[0]:private reflect.User(int,java.lang.String)参数类型[0]:(int,java.lang.String)构造函数[1]:public reflect.User(java.lang.String)参数类型[1]:(java.lang.String)构造函数[2]:public reflect.User()参数类型[2]:()123456789101112 关于Constructor类本身一些常用方法如下(仅部分，其他可查API)， 方法返回值 方法名称 方法说明 Class&lt;T&gt; getDeclaringClass() 返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数） Type[] getGenericParameterTypes() 按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。 String getName() 以字符串形式返回此构造方法的名称。 Class&lt;?&gt;[] getParameterTypes() 按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型 T newInstance(Object... initargs) 使用此 Constructor对象表示的构造函数来创建新实例 String toGenericString() 返回描述此 Constructor 的字符串，其中包括类型参数。 代码演示如下： 123456789101112131415161718192021222324252627282930313233343536373839404142Constructor cs3=clazz.getDeclaredConstructor(int.class,String.class); System.out.println("-----getDeclaringClass-----");Class uclazz=cs3.getDeclaringClass();//Constructor对象表示的构造方法的类System.out.println("构造方法的类:"+uclazz.getName()); System.out.println("-----getGenericParameterTypes-----");//对象表示此 Constructor 对象所表示的方法的形参类型Type[] tps=cs3.getGenericParameterTypes();for (Type tp:tps) &#123; System.out.println("参数名称tp:"+tp);&#125;System.out.println("-----getParameterTypes-----");//获取构造函数参数类型Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();for (Class claz:clazzs) &#123; System.out.println("参数名称:"+claz.getName());&#125;System.out.println("-----getName-----");//以字符串形式返回此构造方法的名称System.out.println("getName:"+cs3.getName()); System.out.println("-----getoGenericString-----");//返回描述此 Constructor 的字符串，其中包括类型参数。System.out.println("getoGenericString():"+cs3.toGenericString()); /**输出结果:-----getDeclaringClass-----构造方法的类:reflect.User-----getGenericParameterTypes-----参数名称tp:int参数名称tp:class java.lang.String-----getParameterTypes-----参数名称:int参数名称:java.lang.String-----getName-----getName:reflect.User-----getoGenericString-----getoGenericString():private reflect.User(int,java.lang.String)*/ 其中关于Type类型这里简单说明一下，Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。getGenericParameterTypes 与 getParameterTypes 都是获取构成函数的参数类型，前者返回的是Type类型，后者返回的是Class类型，由于Type顶级接口，Class也实现了该接口，因此Class类是Type的子类，Type 表示的全部类型而每个Class对象表示一个具体类型的实例，如String.class仅代表String类型。由此看来Type与 Class 表示类型几乎是相同的，只不过 Type表示的范围比Class要广得多而已。当然Type还有其他子类，如： TypeVariable：表示类型参数，可以有上界，比如：T extends Number ParameterizedType：表示参数化的类型，有原始类型和具体的类型参数，比如：List&lt;String&gt; WildcardType：表示通配符类型，比如：?, ? extends Number, ? super Integer 通过以上的分析，对于Constructor类已有比较清晰的理解，利用好Class类和Constructor类，我们可以在运行时动态创建任意对象，从而突破必须在编译期知道确切类型的障碍。 3.2 Field类及其用法Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下： 方法返回值 方法名称 方法说明 Field getDeclaredField(String name) 获取指定name名称的(包含private修饰的)字段，不包括继承的字段 Field[] getDeclaredField() 获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段 Field getField(String name) 获取指定name名称、具有public修饰的字段，包含继承字段 Field[] getField() 获取修饰符为public的字段，包含继承字段 下面的代码演示了上述方法的使用过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** Created by zejian on 2017/5/1.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]*/public class ReflectField &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; Class&lt;?&gt; clazz = Class.forName("reflect.Student"); //获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段, // 否则抛NoSuchFieldException Field field = clazz.getField("age"); System.out.println("field:"+field); //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取 Field fields[] = clazz.getFields(); for (Field f:fields) &#123; System.out.println("f:"+f.getDeclaringClass()); &#125; System.out.println("================getDeclaredFields===================="); //获取当前类所字段(包含private字段),注意不包含父类的字段 Field fields2[] = clazz.getDeclaredFields(); for (Field f:fields2) &#123; System.out.println("f2:"+f.getDeclaringClass()); &#125; //获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段 Field field2 = clazz.getDeclaredField("desc"); System.out.println("field2:"+field2); &#125; /** 输出结果: field:public int reflect.Person.age f:public java.lang.String reflect.Student.desc f:public int reflect.Person.age f:public java.lang.String reflect.Person.name ================getDeclaredFields==================== f2:public java.lang.String reflect.Student.desc f2:private int reflect.Student.score field2:public java.lang.String reflect.Student.desc */&#125; class Person&#123; public int age; public String name; //省略set和get方法&#125; class Student extends Person&#123; public String desc; private int score; //省略set和get方法&#125; 上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下： 123456789101112131415161718192021222324//获取Class对象引用Class&lt;?&gt; clazz = Class.forName("reflect.Student"); Student st= (Student) clazz.newInstance();//获取父类public字段并赋值Field ageField = clazz.getField("age");ageField.set(st,18);Field nameField = clazz.getField("name");nameField.set(st,"Lily"); //只获取当前类的字段,不获取父类的字段Field descField = clazz.getDeclaredField("desc");descField.set(st,"I am student");Field scoreField = clazz.getDeclaredField("score");//设置可访问，score是private的scoreField.setAccessible(true);scoreField.set(st,88);System.out.println(st.toString()); //输出结果：Student&#123;age=18, name='Lily ,desc='I am student', score=88&#125; //获取字段值System.out.println(scoreField.get(st));// 88123456789101112131415161718192021222324 其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下： 方法返回值 方法名称 方法说明 void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 Object get(Object obj) 返回指定对象上此 Field 表示的字段的值 Class&lt;?&gt; getType() 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。 boolean isEnumConstant() 如果此字段表示枚举类型的元素则返回 true；否则返回 false String toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串 String getName() 返回此 Field 对象表示的字段的名称 Class&lt;?&gt; getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段 void setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性 上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如setInt()/getInt()、setBoolean()/getBoolean、setChar()/getChar()等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。 3.3 Method类及其用法Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。下面是Class类获取Method对象相关的方法： 方法返回值 方法名称 方法说明 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 Method[] getDeclaredMethod() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 同样通过案例演示上述方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.lang.reflect.Method; /*** Created by zejian on 2017/5/1.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]*/public class ReflectMethod &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class clazz = Class.forName("reflect.Circle"); //根据参数获取public的Method,包含继承自父类的方法 Method method = clazz.getMethod("draw",int.class,String.class); System.out.println("method:"+method); //获取所有public的方法: Method[] methods =clazz.getMethods(); for (Method m:methods)&#123; System.out.println("m::"+m); &#125; System.out.println("========================================="); //获取当前类的方法包含private,该方法无法获取继承自父类的method Method method1 = clazz.getDeclaredMethod("drawCircle"); System.out.println("method1::"+method1); //获取当前类的所有方法包含private,该方法无法获取继承自父类的method Method[] methods1=clazz.getDeclaredMethods(); for (Method m:methods1)&#123; System.out.println("m1::"+m); &#125; &#125; /** 输出结果: method:public void reflect.Shape.draw(int,java.lang.String) m::public int reflect.Circle.getAllCount() m::public void reflect.Shape.draw() m::public void reflect.Shape.draw(int,java.lang.String) m::public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException m::public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException m::public final void java.lang.Object.wait() throws java.lang.InterruptedException m::public boolean java.lang.Object.equals(java.lang.Object) m::public java.lang.String java.lang.Object.toString() m::public native int java.lang.Object.hashCode() m::public final native java.lang.Class java.lang.Object.getClass() m::public final native void java.lang.Object.notify() m::public final native void java.lang.Object.notifyAll() ========================================= method1::private void reflect.Circle.drawCircle() m1::public int reflect.Circle.getAllCount() m1::private void reflect.Circle.drawCircle() */&#125; class Shape &#123; public void draw()&#123; System.out.println("draw"); &#125; public void draw(int count , String name)&#123; System.out.println("draw "+ name +",count="+count); &#125; &#125;class Circle extends Shape&#123; private void drawCircle()&#123; System.out.println("drawCircle"); &#125; public int getAllCount()&#123; return 100; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而getDeclaredMethod/getDeclaredMethods方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法： 123456789101112131415161718192021222324252627Class clazz = Class.forName("reflect.Circle");//创建对象Circle circle = (Circle) clazz.newInstance(); //获取指定参数的方法对象MethodMethod method = clazz.getMethod("draw",int.class,String.class); //通过Method对象的invoke(Object obj,Object... args)方法调用method.invoke(circle,15,"圈圈"); //对私有无参方法的操作Method method1 = clazz.getDeclaredMethod("drawCircle");//修改私有方法的访问标识method1.setAccessible(true);method1.invoke(circle); //对有返回值得方法操作Method method2 =clazz.getDeclaredMethod("getAllCount");Integer count = (Integer) method2.invoke(circle);System.out.println("count:"+count); /** 输出结果: draw 圈圈,count=15 drawCircle count:100*/ 在上述代码中调用方法，使用了Method类的invoke(Object obj,Object... args)第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。 方法返回值 方法名称 方法说明 Object invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 Class&lt;?&gt; getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型 Type getGenericReturnType() 返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。 Class&lt;?&gt;[] getParameterTypes() 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组 Type[] getGenericParameterTypes() 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型 String getName() 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称 boolean isVarArgs() 判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。 String toGenericString() 返回描述此 Method 的字符串，包括类型参数。 getReturnType方法/getGenericReturnType方法都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息 123456public interface Type &#123; //1.8新增 default String getTypeName() &#123; return toString(); &#125;&#125; 而getParameterTypes/getGenericParameterTypes也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。 3.4 反射包中的Array类在Java的java.lang.reflect包中存在着一个可以动态操作数组的类，Array，它提供了动态创建和访问 Java 数组的方法。Array 允许在执行 get 或 set 操作进行取值和赋值。在Class类中与数组关联的方法是： 方法返回值 方法名称 方法说明 Class&lt;?&gt; getComponentType() 返回表示数组元素类型的 Class，即数组的类型 boolean isArray() 判定此 Class 对象是否表示一个数组类。 java.lang.reflect.Array中的常用静态方法如下： 方法返回值 方法名称 方法说明 static Object set(Object array, int index) 返回指定数组对象中索引组件的值。 static int getLength(Object array) 以 int 形式返回指定数组对象的长度 static object newInstance(Class&lt;?&gt; componentType, int... dimensions) 创建一个具有指定类型和维度的新数组。 static Object newInstance(Class&lt;?&gt; componentType, int length) 创建一个具有指定的组件类型和长度的新数组。 static void set(Object array, int index, Object value) 将指定数组对象中索引组件的值设置为指定的新值。 下面通过一个简单例子来演示这些方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package reflect; import java.lang.reflect.Array; /*** Created by zejian on 2017/5/1.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]*/public class ReflectArray &#123; public static void main(String[] args) throws ClassNotFoundException &#123; int[] array = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; //获取数组类型的Class 即int.class Class&lt;?&gt; clazz = array.getClass().getComponentType(); //创建一个具有指定的组件类型和长度的新数组。 //第一个参数:数组的类型,第二个参数:数组的长度 Object newArr = Array.newInstance(clazz, 15); //获取原数组的长度 int co = Array.getLength(array); //赋值原数组到新数组 System.arraycopy(array, 0, newArr, 0, co); for (int i:(int[]) newArr) &#123; System.out.print(i+","); &#125; //创建了一个长度为10 的字符串数组， //接着把索引位置为6 的元素设为"hello world!"，然后再读取索引位置为6 的元素的值 Class clazz2 = Class.forName("java.lang.String"); //创建一个长度为10的字符串数组，在Java中数组也可以作为Object对象 Object array2 = Array.newInstance(clazz2, 10); //把字符串数组对象的索引位置为6的元素设置为"hello" Array.set(array2, 6, "hello world!"); //获得字符串数组对象的索引位置为5的元素的值 String str = (String)Array.get(array2, 6); System.out.println(); System.out.println(str);//hello &#125; /** 输出结果: 1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, hello world! */&#125; 通过上述代码演示，确实可以利用Array类和反射相结合动态创建数组，也可以在运行时动态获取和设置数组中元素的值，其实除了上的set/get外Array还专门为8种基本数据类型提供特有的方法，如setInt/getInt、setBoolean/getBoolean，其他依次类推，需要使用是可以查看API文档即可。除了上述动态修改数组长度或者动态创建数组或动态获取值或设置值外，可以利用泛型动态创建泛型数组如下： 1234567891011121314151617181920212223242526/** * 接收一个泛型数组，然后创建一个长度与接收的数组长度一样的泛型数组， * 并把接收的数组的元素复制到新创建的数组中， * 最后找出新数组中的最小元素，并打印出来 * @param a * @param &lt;T&gt; */ public &lt;T extends Comparable&lt;T&gt;&gt; void min(T[] a) &#123; //通过反射创建相同类型的数组 T[] b = (T[]) Array.newInstance(a.getClass().getComponentType(), a.length); for (int i = 0; i &lt; a.length; i++) &#123; b[i] = a[i]; &#125; T min = null; boolean flag = true; for (int i = 0; i &lt; b.length; i++) &#123; if (flag) &#123; min = b[i]; flag = false; &#125; if (b[i].compareTo(min) &lt; 0) &#123; min = b[i]; &#125; &#125; System.out.println(min);&#125; 毕竟我们无法直接创建泛型数组，有了Array的动态创建数组的方式这个问题也就迎刃而解了。 12//无效语句，编译不通T[] a = new T[];12 ok~，到这反射中几个重要并且常用的类我们都基本介绍完了，但更重要是，我们应该认识到反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM只会简单地检查这个对象，判断该对象属于那种类型，同时也应该知道，在使用反射机制创建对象前，必须确保已加载了这个类的Class对象，当然这点完全不必由我们操作，毕竟只能JVM加载，但必须确保该类的”.class”文件已存在并且JVM能够正确找到。关于Class类的方法在前面我们只是分析了主要的一些方法，其实Class类的API方法挺多的，建议查看一下API文档，浏览一遍，有个印象也是不错的选择，这里仅列出前面没有介绍过又可能用到的API： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 修饰符、父类、实现的接口、注解相关 */ //获取修饰符，返回值可通过Modifier类进行解读public native int getModifiers();//获取父类，如果为Object，父类为nullpublic native Class&lt;? super T&gt; getSuperclass();//对于类，为自己声明实现的所有接口，对于接口，为直接扩展的接口，不包括通过父类间接继承来的public native Class&lt;?&gt;[] getInterfaces();//自己声明的注解public Annotation[] getDeclaredAnnotations();//所有的注解，包括继承得到的public Annotation[] getAnnotations();//获取或检查指定类型的注解，包括继承得到的public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass);public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass); /** * 内部类相关 *///获取所有的public的内部类和接口，包括从父类继承得到的public Class&lt;?&gt;[] getClasses();//获取自己声明的所有的内部类和接口public Class&lt;?&gt;[] getDeclaredClasses();//如果当前Class为内部类，获取声明该类的最外部的Class对象public Class&lt;?&gt; getDeclaringClass();//如果当前Class为内部类，获取直接包含该类的类public Class&lt;?&gt; getEnclosingClass();//如果当前Class为本地类或匿名内部类，返回包含它的方法public Method getEnclosingMethod(); /** * Class对象类型判断相关 *///是否是数组public native boolean isArray(); //是否是基本类型public native boolean isPrimitive();//是否是接口public native boolean isInterface();//是否是枚举public boolean isEnum();//是否是注解public boolean isAnnotation();//是否是匿名内部类public boolean isAnonymousClass();//是否是成员类public boolean isMemberClass();//是否是本地类public boolean isLocalClass(); ok~，本篇到此完结。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>JVM</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-反射机制的核心原理]]></title>
    <url>%2F2018%2F07%2F09%2FJava-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[0. 说明 由于最近被一个同学问到Java的反射，我给它讲了反射，可是发现，我只是讲了什么是反射，别人却说，反射的实现原理是啥，这才发现我答非所问。后来去网上查了资料，大部分都只是讲到反射的使用，关于原理的这部分，却很少涉及，这是又拿起了《深入理解Java虚拟机》，尝试从中找答案。 1. 概述 引述下百度百科关于反射的定义：Java反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制 关于反射，阿里的一位工程师总结为6个字: 自描述、自控制， 自描述：通过反射动态获取类、属性、方法的信息 ； 自控制：构建对象并控制对象的属性和行为 2. 实例123456789101112131415public class T4 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; Class clazz = Class.forName("test.T"); //test.t 这是类的全名 test是包名 //Class clazz = test.T.class; Object object = clazz.newInstance(); Method method = clazz.getMethod("hello"); method.invoke(object); &#125;&#125; class T&#123; public void hello()&#123; System.out.println("hello world!"); &#125;&#125; 这里只是演示了一个反射的简单使用实例，下文将针对这个实例做详细的解释 3. 核心概念1. Class类 在反射中有一个核心的类型，那就是Class类型，可以理解为Java中类的类型， 它是类的访问入口，也是反射的关键点，它是在类加载时创建，不能够显式创建，后面的类加载会详细讲到 java.lang.Class对象，它也是一个对象，也是Object的子类。获得Class对象，可以通过三种方式： 通过类的全名:className.class： 通过类的实例：t.getClass()，其中t为某个类的实例 通过Class.forName()方法,参数为类的全名，见示例 获得类的类类型（Class类型），是获得类的访问入口，才有后续的反射操作 2. 运行时状态 对于对象的使用，我们的操作经常是这样的：T t = new T(),T为某个类名，运行步骤大体为： 在Java中，程序中一般的对象的类型都是在编译器就确定下来，而Java反射机制可以动态的创建对象并调用其属性，即使这个对象的类型在编译器是未知的 反射的核心就是JVM在运行时才动态加载类或者调用方法/访问属性。 3. 类加载 类加载主要包括3个步骤：加载、连接（验证、准备、解析）、初始化；这里我们重点讨论加载过程： 加载 是 类加载 （Class Loading）过程中的一个阶段，在加载阶段中，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将该字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存（Java内存模型）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口，Class对象比较特殊，它虽然是对象，但是存放在方法区里面 这里生成的Class对象，对于反射而言，至关重要 4. 方法区 方法区是Java运行时数据区的划分的一部分，它与Java堆一样，是各个线程共享的内存区域，它用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 方法区存放着Class对象，它是反射的入口 4. 原理 讲完了上面的核心概念，下面对反射的基本原理做一下总结： JVM在运行时通过类的全限定名、实例的getClass()方法等获取Class对象信息，然后从方法区中匹配到该类的Class对象，它保存了类的类型、方法信息，构造器、字段等。然后从Class对象中动态获取类信息或者构造类对象，完成反射过程 以上为个人理解，如有错误，还望指出]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-Java中三种代理模式]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java%E4%B8%AD%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式是常用的结构性设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。可以在目标对象的基础上，增加额外的功能操作，即扩展目标对象的功能。 体现编程思想：不修改原模块代码或方法，通过代理的方式来扩展 完整代码见文末链接 1. 静态代理 静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同的父类 关键：在编译期确定代理对象，在程序运行前代理类的.class文件就已经存在 如：在代理对象中实例化被代理对象或者将被代理对象传入代理对象的构造方法 示例代码 1234567891011121314151617181920212223242526272829303132//对象接口public interface Subject &#123; public void doSomething();&#125;//接口真实实现类（被代理对象）public class SubjectImpl implements Subject&#123; @Override public void doSomething() &#123; System.out.println("do something....."); &#125;&#125;//接口代理实现类 （代理对象）public class SubjectProxy implements Subject &#123; Subject subjectImlp = new SubjectImpl(); @Override public void doSomething() &#123; subjectImlp.doSomething(); //调用真事实现类的方法 &#125;&#125;//测试方法public class StaticProxyTest &#123; @Test public void test()&#123; Subject sub = new SubjectProxy(); //实例化代理实现类对象 sub.doSomething(); &#125;&#125; 总结： 可以做到在不修改目标对象的功能前提下，对目标功能扩展 缺点： 代理类与委托类实现相同的接口，同时要实现相同的方法，这样就出现了大量的代码重复。如果接口增加一个方法，除了实现类需要实现这个方法外，所有代理类也需要实现该方法。增加了代码维护的复杂度 2. 动态代理 在运行期，通过反射机制创建一个实现了一组接口的新类 是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)，因此也叫JDK代理 接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强 与前面文章Spring-AOP核心原理及手写实现对应 JDK中生成代理对象的API 代理类所在的包：java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法，该方法需要接受三个参数，完整的写法是 static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler) 注意该方法在Proxy类中是静态方法，且接受的三个参数一次为： ClassLoader loader:指定当前目标对象使用类加载器,用null表示默认类加载器 Class [] interfaces:需要实现的接口数组 InvocationHandler handler:调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入 java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。 123// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。Object invoke(Object proxy, Method method, Object[] args) 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//接口public interface Subject &#123; public void doSomething();&#125;////////////////////////////////////////////////接口真实实现类public class SubjectImpl implements Subject &#123; @Override public void doSomething() &#123; System.out.println("dynamic doing something .... "); &#125;&#125;//--------------------------------------------------//代理处理类public class ProxyHandler implements InvocationHandler &#123; private Object target; /** * 绑定委托对象，并返回代理类 */ public Object bind(Object target)&#123; this.target = target; //绑定该类实现的所有接口，取得代理类 return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; //这里就可以进行所谓的AOP编程 //执行前方法 System.out.println("before..."); result = method.invoke(target,args); //执行后方法 System.out.println("after..."); return result; &#125;&#125;//------------------------------------------------------------------------------------------//测试类public class ProxyHandlerTest &#123; @Test public void bind() &#123; var proxy = new ProxyHandler(); //绑定该类实现的所有接口 Subject sub = (Subject) proxy.bind(new SubjectImpl()); sub.doSomething(); &#125;&#125; 总结： 代理对象不需要实现接口，但目标对象一定要实现接口，否则不能用动态代理 3. Cglib代理 上面的静态代理和动态代理模式都是需要要求目标对象就是一个接口或者多个接口，但有时候目标对象就是一个单独的对象，并没有实现任何接口，这个时候就可以使用构建目标对象子类的方式实现代理，这种方法就叫做： Cglib代理 Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展 Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的子类. 代理的类不能为final,否则报错；目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//真实实现类 无继承接口public class SubjectImpl &#123; public void doSomeThing()&#123; System.out.println("cglib proxy doing something..."); &#125;&#125;//--------------------------------------------------------------------------------------import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * Cglib子类代理工厂 * 对SubjectImpl 在内存中工台构建一个子类对象 * @author briarbear * @blog https://briarbear.github.io * @create 2018-07-05-15:37 */public class ProxyFactory implements MethodInterceptor &#123; //MethodInterceptor 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,需要引入Spring core //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1. 工具类 var en = new Enhancer(); //2. 设置父类 en.setSuperclass(target.getClass()); //3. 设置回调函数 en.setCallback(this); //4. 创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("before...."); //执行目标对象的方法 Object result = method.invoke(target,args); System.out.println("afer..."); return result; &#125;&#125;//----------------------------------------------------------------------------------------//测试类 @Test public void test()&#123; //目标对象 var target = new SubjectImpl(); //代理对象 var proxy = (SubjectImpl)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.doSomeThing(); &#125; 总结 在Spring AOP编程中，如果加入容器的目标对象有实现接口,用JDK代理。如果目标对象没有实现接口,用Cglib代理 相关链接 完整示例代码 java的动态代理机制详解 知乎-动态代理的作用是什么？-郭无心 java的三种代理模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-Synchronize与volatile应用示例（售票系统）]]></title>
    <url>%2F2018%2F07%2F04%2FJava%E5%B9%B6%E5%8F%91-Synchronize%E4%B8%8Evolatile%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[场景描述：假设现在我们总共有1000张票要进行出售，共有10个出售点，那么当售票到最后只有一张票时每个售票点如何去处理这唯一的一张票？或者对于某一张票而言，假设它正在售票站1售票的程序执行过程中，但是还没有出售，那么此时，其他售票站改如何去处理这张票呢？ 这是典型的并发问题，涉及线程同步，在Java总可以采用锁的机制实现，本文将例举synchronize与volatile的原子变量类来解决, 每个方案都是详细的代码解释，完整代码可见文末链接 1. synchronize解决方案1234567891011121314151617181920212223242526272829303132333435public class SynchronizeExample &#123; public static void main(String[] args) &#123; int n = 10; Thread[] threads = new Thread[n];//10个窗口售卖，开10个进程 for (int i = 0; i &lt; n; i++) &#123; threads[i] = new Thread(new ticket()); threads[i].setName(i+1+"号窗口"); threads[i].start(); &#125; &#125;&#125; class ticket implements Runnable&#123; private static int count = 1000; private static String key = "key"; //通过key这个互斥变量来控制对count的访问 @Override public void run() &#123; while (count &gt; 0)&#123; synchronized (key)&#123; if (count &gt; 0)&#123; System.out.println("第"+Thread.currentThread().getName()+"在卖第"+(1001-count)+"张票"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count--; &#125;else &#123; break; &#125; &#125; &#125; System.out.println("第"+Thread.currentThread().getName()+"的票已经卖完"); &#125;&#125; 2. volatile+AtomicInteger解决方案12345678910111213141516171819202122232425262728293031323334/*** 同样是买票问题 尝试使用原子类 + volatile 解决*/public class SynchronizeExample2 &#123; public static void main(String[] args) &#123; int windows = 10; for (int i = 0; i &lt; windows; i++) &#123; Thread thread = new Thread(new Sale()); thread.setName(i+1+"号窗口"); thread.start(); &#125; &#125;&#125; class Sale implements Runnable&#123; //保证count的自增操作的原子性，使用volatile保证共享变量的可见性 private static volatile AtomicInteger count = new AtomicInteger(0); @Override public void run() &#123; int temp =count.get(); while (temp &lt;= 1000)&#123; temp = count.getAndIncrement(); if (temp &lt; 1000)&#123; System.out.println("第"+Thread.currentThread().getName()+"在卖第"+(temp+1)+"张票"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println("第"+Thread.currentThread().getName()+"的票已经卖完"); &#125;&#125; 相关链接 示例完整源码-github]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Synchronize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-阻塞队列实现生产者消费者]]></title>
    <url>%2F2018%2F07%2F04%2FJava%E5%B9%B6%E5%8F%91-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[1. 阻塞队列 前文中讲到过：阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。阻塞队列常用于生产者和消费者的场景，生产者是向队列中添加元素的线程，消费者是从队列取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器 完整代码见文末 2. 消费者12345678910111213141516171819202122232425262728293031323334/** * 消费者 */public class Consumer implements Runnable &#123; protected BlockingQueue&lt;Object&gt; queue; public Consumer(BlockingQueue&lt;Object&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true)&#123; try &#123; Object object = queue.take(); //从队列中取 System.out.println("consumed resource... the queue size is" + queue.size()); take(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 消费对象 void take(Object obj)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("comsuming object " + obj); &#125;&#125; 3. 生产者1234567891011121314151617181920212223242526272829303132333435/** * 生产者 */public class Producer implements Runnable &#123; protected BlockingQueue&lt;Object&gt; queue; public Producer(BlockingQueue&lt;Object&gt; queue) &#123; this.queue = queue; &#125; //生产者创建一个资源（Object对象）并将它存入到队列中，如果队列已满，它将会等待到消费者线程从队列中取走资源，所以队列长度永远不会超过20 @Override public void run() &#123; while (true)&#123; Object object = getResource(); try &#123; queue.put(object); System.out.println("Produced resource...the queue size is " + queue.size()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //生产对象 Object getResource()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return new Object(); &#125;&#125; 4. 测试启动123456789101112131415161718192021222324252627/** * 测试启动类 * 分别启动4个生成者线程，3个消费者线程 * 生产者不断添加对象到队列中，消费者不断从队列中取出 * 运行10s后，程序退出 */public class ProducerConsumerExample &#123; public static void main(String[] args) throws InterruptedException &#123; int numProducers = 4; //生产者数量 int numConsumers = 3; //消费者数量 //使用LinkedBlockingDeque - 一个由链表结构组成的双向阻塞队列 //BlockingQueue&lt;Object&gt; queue = new LinkedBlockingDeque&lt;&gt;(20); BlockingQueue&lt;Object&gt; queue = new LinkedBlockingQueue&lt;&gt;(20); //也可以使用链表阻塞队列 //分别启动生产者、消费者 for (int i = 0; i &lt; numProducers; i++) &#123; new Thread(new Producer(queue)).start(); &#125; for (int i = 0; i &lt; numConsumers; i++) &#123; new Thread(new Consumer(queue)).start(); &#125; Thread.sleep(10*1000); Thread.yield(); System.exit(0); &#125;&#125; 运行结果： 12345678910111213consumed resource... the queue size is1Produced resource...the queue size is 3Produced resource...the queue size is 2consumed resource... the queue size is2consumed resource... the queue size is3Produced resource...the queue size is 3Produced resource...the queue size is 4Produced resource...the queue size is 2Produced resource...the queue size is 3Produced resource...the queue size is 4Produced resource...the queue size is 5comsuming object java.lang.Object@619f2f27...... 相关链接 完整代码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-Java中的阻塞队列]]></title>
    <url>%2F2018%2F07%2F04%2FJava%E5%B9%B6%E5%8F%91-Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本文摘自《Java并发编程的艺术-方腾飞》 本节将介绍什么是阻塞队列，以及Java中阻塞队列的4种四种处理方式，并介绍Java7（Java8相同）中提供的7种阻塞队列，稍后分析阻塞队列的一种实现方式 1. 什么是阻塞队列​ 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器 ​ 在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表1所示 插入和移除操作的 4 中处理方式 方法 / 处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove(e) poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 抛出异常：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（&quot;Queue full&quot;）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException异常 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null 一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take 元素，队列会阻塞住消费者线程，直到队列不为空 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出 这两个附加操作的 4 种处理方式不方便记忆，所以我找了一下这几个方法的规律。put和 take 分别尾首含有字母 t，offer 和 poll 都含有字母 o 注意：如果是无界阻塞队列，队列不可能会出现满的情况，所以使用 put 或 offer 方法永远不会被阻塞，而且使用 offer 方法时，该方法永远返回 true 2. Java里的阻塞队列JDK7提供了7个阻塞队列，如下： ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列 DelayQueue：一个使用优先级队列实现的无界阻塞队列 SynchronousQueue：一个不存储元素的阻塞队列 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 1. ArrayBlockingQueue ​ ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序 默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列 1ArrayBlockingQueue fairQueue = new ArrayBlockingQueue (1000. true) ; 访问者的公平性是使用可重入锁实现的，代码如下： 12345678public ArrayBlockingQueue (int capacity, boolean fair)&#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 2. LinkedBlockingQueue LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX VALUE。此队列按照先进先出的原则对元素进行排序。 3. PriorityBlockingQueue PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 4. DelayQueue DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素 DelayQueue非常有用，可以将DelayQueue运用在以下应用场景: 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的 5. SynchronousQueue SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列 123public SynchronousQueue(boolean fair)&#123; transferer = fair?new TransferQueue():new TransferStack();&#125; SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue 6. LinkedTransferQueue LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。 transfer方法 如果当前有消费者正在等待接收元素（消费者使用take0方法或带时间限制的poll0方法时），transfer方法可以把生产者传人的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下 12Node pred = tryAppend(S,haveData);return awaitMatch(s,pred,e,(how = TIMED),nanos); 第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield0方法来暂停当前正在执行的线程，并执行其他线程 tryTransfer方法 tryTransfer方法是用来试探生产者传人的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。 对于带有时间限制的tryTransfer(E e，long timeout，TimeUnit unit)方法，试图把生产者传人的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。 7. LinkedBlockingDeque LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时人队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取( peek)或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-AOP核心原理及手写实现]]></title>
    <url>%2F2018%2F07%2F03%2FSpring-AOP%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%8F%8A%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 基本原理 Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截（AspectJ静态代理框架能够实现更为高级的功能，本文不做介绍） Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法 Spring AOP中的动态代理主要有两种方式 : JDK动态代理：JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类 CGLIB动态代理： 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的 下面将手动实现一个AOP功能（完整代码见文末） 2. JDK动态代理1. 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//1. 服务接口类public interface HelloService &#123; public void sayHello(String name);&#125;//2. 服务实现类public class HelloServiceImpl implements HelloService &#123; @Override public void sayHello(String name) &#123; System.err.println("hello "+name); &#125;&#125;//3. 代理类/** * 代理类 实现InvocationHandler接口 */public class HelloServiceProxy implements InvocationHandler &#123; /** * 真实服务对象 */ private Object target; /** * 绑定委托对象，并返回一个代理类 */ public Object bind(Object target)&#123; this.target = target; //取得代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this); &#125; /** * 通过代理对象调用方法首先进入这个方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.err.println("###########我的JDK动态代理############"); Object result = null; //反射方法前调用 System.err.println("我准备说hello"); // 执行方法,相当于调用HelloServiceImpl类的sayHello方法. result = method.invoke(target, args); // 反射方法后调用. System.err.println("我说过hello了."); return result; &#125;&#125; 2. 测试结果12345678public class HelloServiceMain &#123; public static void main(String[] args) &#123; HelloServiceProxy helloHandler = new HelloServiceProxy(); HelloService proxy = (HelloService) helloHandler.bind(new HelloServiceImpl()); proxy.sayHello("xiongzp08"); System.err.println(proxy.getClass()); &#125;&#125; 运行结果 1234我准备说hellohello xiongzp08我说过hello了.class com.sun.proxy.$Proxy0 可以看到是为JDK代理(com.sun.proxy.$Proxy*) 3. CGLIB动态代理 下面代码演示的是CGLIB实现动态代理，这里要用到CGLIB框架，注意导入依赖，pom.xml文件增加内容如下 123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt;&lt;/dependency&gt; 1. 主要代码123456789101112131415161718192021222324252627282930313233343536//1. CGLIB代理类//这里面用到了上一节中部分代码，未列出，完整代码见文末连接// 实现MethodInterceptor接口public class HelloServiceCglib implements MethodInterceptor &#123; private Object target; /** * 创建代理对象，并返回 */ public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); //回调方法 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); &#125; /** * 需实现intercept接口 */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.err.println("我是CGLIB动态代理"); Object result; // 反射方法前调用. System.err.println("我准备说hello."); // 执行方法,相当于调用HelloServiceImpl类的sayHello方法. result = methodProxy.invokeSuper(o, objects); // 反射方法后调用. System.err.println("我说过hello了."); return result; &#125;&#125; 2. 测试结果12345678910public class HelloServiceMain &#123; public static void main(String[] args) &#123; HelloServiceCglib cglib = new HelloServiceCglib(); HelloService service = (HelloService) cglib.getInstance(new HelloServiceImpl()); service.sayHello("xiongzp08"); System.err.println(service.getClass()); &#125;&#125; 运行结果 1234我准备说hello.hello xiongzp08我说过hello了.class com.xzp.dynamic_proxy.HelloServiceImpl$$EnhancerByCGLIB$$af1808f4 相关链接 完整示例代码-GitHub]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IOC核心原理及手写实现]]></title>
    <url>%2F2018%2F07%2F03%2FSpring-IOC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%8F%8A%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[0. IOC基本原理 建议不要硬着头皮看Spring代码，本身代码800多m，就是不上班开始看，也不知道什么时候看完，如果想学学IOC，控制反转这些建议看看jodd项目，比较简练，但是我仍然不建议过多看这些框架的代码，因为这些代码要完成任务需要很多琐碎的类实现，比如读取某个包下的所有类，解析class的头文件，反射各种信息，再加上封装。很有可能读源码的过程中掉在各种细节出不来，所以读这种源码不必事无巨细，理解原理即可。 ​ 基本原理其实就是通过反射解析类及其类的各种信息，包括构造器，方法及其参数，属性。然后将其封装成bean定义信息类、constructor信息类、method信息类、property信息类，最终放在一个map中，也就是所谓的container，池等等，其实就是个map。 当你写好配置文件，启动项目后，框架会按照你的配置文件找到那个要scan的包， 然后解析包里面的所有类，找到所有@bean、@service等注解的类，利用反射解析它们，包括解析构造器，方法，属性等，然后封装成各种信息类到一个map里 每当你需要一个bean的时候，框架就会从container找到是不是有这个类的定义。如果找到就通过构造器new出来（这就是控制反转，不用你new，框架帮你new） 再在这个类找是不是有要注入的属性或者方法，比如标有@autowrite的属性，如果有则还是到container找对应的解析类，new出对象，并通过之前解析出来的信息类找到setter方法，然后用该方法注入对象（这就是依赖注入）。 如果其中有一个类container里没找到，则抛出异常，比如常见的spring无法找到该类定义，无法wire的异常。 还有就是嵌套bean则用了一下递归，container会放到servletcontext里面，每次reQuest从servletcontext找这个container即可，不用多次解析类定义。 如果bean的scope是singleton，则会重用这个bean不会再重新创建，将这个bean放到一个map里，每次用都先从这个map里面去找。 如果scope是session，则该bean会放到session里面，仅此而已。 1. 说明 IOC是Spring中核心功能之一，基本原理就是通过反射解析类及其各种信息，然后封装成对象，存放在map中，即bean容器。可以根据其基本原理简单实现一个Spring IOC模块,完整代码见文末链接。 模拟同学会面的打招呼场景，定义 Greeting接口，包含 hello方法，实现对某人打招呼Hello类实现该 Greeting 接口，实现hello方法。然后定义人类Person的抽象类，具备属性 name，Student为该类的继承类。同时还包括BeanFactory接口，以及负责xml文件解析与bean创建等 2. 基本类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 打招呼 */public interface Greeting &#123; /** * 对某个打招呼 * @param p */ public void hello(Person p);&#125;public class Hello implements Greeting &#123; @Override public void hello(Person p) &#123; System.out.println("hello to "+p.name); &#125;&#125;/** * Person抽象类 */public abstract class Person &#123; public String name; //姓名&#125;/** * 学生类 */public class Student extends Person&#123;&#125;/** * 学生服务类 */public class StudentService &#123; private Greeting greeting; public Greeting getGreeting() &#123; return greeting; &#125; public void setGreeting(Greeting greeting) &#123; this.greeting = greeting; &#125; /** * 对某人打招呼 * @param p */ public void helloService(Person p)&#123; this.greeting.hello(p); &#125;&#125; 上述代码中，学生服务类中的 helloService方法，表示调用 greeting的方法，完成对某个打招呼的功能，这里依赖于另外一个对象Person类，这样的依赖注入，通过IOC来实现 3. 配置解析与容器类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * BeanFactory接口 */public interface BeanFactroy &#123; public Object getBean(String name);&#125;/** * IOC 容器类 */public class ClassPathXmlApplicationContext implements BeanFactroy &#123; private Map&lt;String,Object&gt; beans = new HashMap&lt;String, Object&gt;(); //IOC容器 /** * 构造函数，完成xml文件的解析 */ public ClassPathXmlApplicationContext() throws JDOMException, IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; SAXBuilder builder = new SAXBuilder(); Document document = builder.build(this.getClass().getClassLoader().getResource("iocbeans.xml")); Element root = document.getRootElement(); //获得bean元素集合 List&lt;Element&gt; list = root.getChildren("bean"); for (int i = 0; i &lt; list.size(); i++) &#123; Element element = list.get(i); String id = element.getAttributeValue("id"); String clazz = element.getAttributeValue("class"); System.out.println(id + " : " + clazz); //通过反射构建对象// Object obj = Class.forName(clazz).newInstance() Object obj = Class.forName(clazz).getDeclaredConstructor().newInstance(); //添加到map容器中 beans.put(id,obj); //注入依赖 for (Element property : element.getChildren("property")) &#123; String name = property.getAttributeValue("name"); String injectBean = property.getAttributeValue("bean"); Object propertyObj = beans.get(injectBean); //拼接setter方法 String methodNmae = "set" + name.substring(0,1).toUpperCase() + name.substring(1); System.out.println("method name = " + methodNmae); Method m = obj.getClass().getMethod(methodNmae,propertyObj.getClass().getInterfaces()); //注入 m.invoke(obj,propertyObj); &#125; &#125; &#125; @Override public Object getBean(String name) &#123; return beans.get(name); &#125;&#125; 4. xml配置文件12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans&gt; &lt;bean id = "hello" class = "ioc.Hello"/&gt; &lt;bean id = "student" class="ioc.Student"/&gt; &lt;bean id = "service" class="ioc.StudentService"&gt; &lt;property name = "greeting" bean = "hello"/&gt; &lt;/bean&gt;&lt;/beans&gt; 5. 功能测试123456789101112public class StudentServiceTest &#123; @Test public void helloService() throws NoSuchMethodException, IllegalAccessException, IOException, InstantiationException, JDOMException, InvocationTargetException, ClassNotFoundException &#123; //var jdk10语法 var factory = new ClassPathXmlApplicationContext(); var service = (StudentService)factory.getBean("service"); //获得service对象实例 var student = (Student)factory.getBean("student"); //获得student对象实例 student.name = "xiongzp08"; service.helloService(student); &#125;&#125; 6. 运行结果1234567hello : ioc.Hellostudent : ioc.Studentservice : ioc.StudentServicemethod name = setGreetinghello to xiongzp08Process finished with exit code 0 相关链接 完整代码 Spring Ioc实现机制——简析 知乎-王奕然]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-三种工厂模式]]></title>
    <url>%2F2018%2F06%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建议结合示例源码理解 1 简单工厂模式 简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式 简单工厂模式的要点在于：当你需要什么，只需要传入一个参数，就可以获取你所需要的对象，而无须知道其创建细节 类图: 主要优点： 客户端免除直接创建对象，实现对象创建于使用的分离 客户端无需知道具体产品类的类名，只需要知道对应的参数即可 通过引入配置文件，可以在不修改客户端代码的情况下更换新的产品类 主要缺点： 由于产品类中集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要收到影响 增加系统中类的个数，增加了系统的复杂度 系统拓展困难，一旦有新产品就不得不修改工厂逻辑，不利于拓展与维护 使用场景： 工厂类负责创建的对象比较少， 客户端只知道传入工厂类的参数，对于如何创建对象不关心 2 工厂方法模式 简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则” 。 在工厂方法中，我们不在提供统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂， 一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足，工厂方法模式是使用频率最高的设计模式之一，是很多开源框架与API类库的核心模式 类图： 主要优点： 用户创建产品，只需要关心产品对应的工厂，无需关心细节，甚至无需知道具体产品类的类名 在加入新产品时，无需修改客户端，只需要增加一个具体工厂与具体产品就可以，符合开闭原则 主要缺点： 增加新产品时，需要编写具体的产品类，还需要提供对应的工厂类，增加了系统的复杂度 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度 适用场景： 客户端不知道它所需要的对象的类 ，只知道对应的工厂名称 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展 3 抽象工厂模式 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产 抽象工厂模式是工厂模式的进一步的延伸，由于它提供了功能更为强大的工厂类，并具备较好的可拓展性，在软件开发张得以广泛应用 类图 主要优点： 增加新产品很方便，符合“开闭原则”， 主要缺点： 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则 适用场景： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 相关链接： 推荐书籍（原文）：设计模式Java版 实例源码：-github]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-ThreadLocal理解与适用场景]]></title>
    <url>%2F2018%2F06%2F26%2FJava%E5%B9%B6%E5%8F%91-ThreadLocal%E7%90%86%E8%A7%A3%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量 ThreadLocal并不是解决多线程共享变量的问题，既然变量不共享，更谈不上同步到问题 ThreadLocal 提供了线程本地变量的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收 1. ThreadLocal的使用1. 创建ThreadLocal变量：1private ThreadLocal&lt;String&gt; myThreadLocal = new ThreadLocal&lt;String&gt;(); // 制定泛型类型 代码实例化一个ThreadLocal对象，只需要实例化一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal变量实例，但是每个线程只能访问到自己通过调用ThreadLocal的set()方法设置的值，即使在两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对象的值 2. 访问ThreadLocal变量12myThreadLocal.set("A thread local value"); // 设置变量值String threadLocalValue = myThreadLocal.get() //获取变量值 3. 初始化ThreadLocal变量的值 由于在ThreadLocal对象中设置的值只能被设置这个值的线程访问到，线程无法在ThreadLocal对象上使用set()方法保存一个初始值，并且这个初始值能被所有线程访问到。 但是我们可以通过创建一个ThreadLocal的子类并且重写initialValue()方法，来为一个ThreadLocal对象指定一个初始值 12345private ThreadLocal myThreadLocal = new ThreadLocal&lt;String&gt;() &#123; @Override protected String initialValue() &#123; return "This is the initial value"; &#125;&#125;; 4. 完整的ThreadLocal使用实例1234567891011121314151617181920212223242526272829package concurrent.thread_local;public class ThreadLocalExample &#123; public static class MyRunnable implements Runnable&#123; //ThreadLocal变量 private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public void run() &#123; threadLocal.set((int)(Math.random() * 1000)); try &#123; Thread.sleep(2000); //休眠2秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread1 = new Thread(myRunnable); Thread thread2 = new Thread(myRunnable); thread1.start(); thread2.start(); thread1.join(); //等待线程终止 thread2.join(); &#125;&#125; 上面的例子创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run()方法，并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并且调用的set()方法被同步了，则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是一个ThreadLocal对象，因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同的值。 2. 关于Inheritable ThreadLocal InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值 3. ThreadLocal原理 既然每个访问的ThreadLocal变量的线程都有自己的一个“本地”实例副本，每一个线程的Thread对象中都有一个ThreadLocalMap对象，该Map中，键是ThreadLocal. threadLocalHashCode，本地线程变量为值。 ThreadLocal对象就是当前线程的ThreadLocalMap 的访问入口，每一个ThreadLocal 对象都包含了一个独一无二的threadLocalHashCode 值，使用这个值就可以在线程K-V 值对中找回对应的本地线程变量。 4. ThreadLocalMap与内存泄漏问题 由于每个线程访问某 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例的映射，如果不删除这些引用（映射），则这些 ThreadLocal 不能被回收，可能会造成内存泄漏 解决方案 对于已经不再被使用且已被回收的 ThreadLocal 对象，它在每个线程内对应的实例由于被线程的 ThreadLocalMap 的 Entry 强引用，无法被回收，可能会造成内存泄漏 针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏 5. 适用场景如上文所述，ThreadLocal 适用于如下两种场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 对于第一点，每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。 对于第二点，可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅 6. 案例 对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。如果不使用 ThreadLocal，可以在每个线程内构建一个 Session实例，并将该实例在多个方法间传递,耦合度太高。 使用 ThreadLocal 改造后的代码，不再需要在各个方法间传递 Session 对象，并且也非常轻松的保证了每个线程拥有自己独立的实例 7. 总结 ThreadLocal 并不解决线程间共享数据的问题 ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题 ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题 ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏 ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 相关链接Java进阶（七）正确理解Thread Local的原理与适用场景]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-ArrayDeque工作原理及实现]]></title>
    <url>%2F2018%2F06%2F26%2FJava%E9%9B%86%E5%90%88-ArrayDeque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 1. 概述 Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue. 以循环数组实现的双向Queue。大小是2的倍数，默认是16。 普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组0，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-PriorityQueue工作原理及实现]]></title>
    <url>%2F2018%2F06%2F26%2FJava%E9%9B%86%E5%90%88-PriorityQueue%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】 原文链接 参考资料基于最小堆（小根堆）的topn算法基于堆实现的优先级队列：PriorityQueue 解决 Top K 问题Java优先队列（PriorityQueue）示例JDK源码研究PriorityQueue（优先队列）优先级队列：PriorityQueue]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-CopyOnWriteArrayList工作原理及实现]]></title>
    <url>%2F2018%2F06%2F26%2FJava%E9%9B%86%E5%90%88-CopyOnWriteArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。 因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。 增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-LinkedList工作原理及实现]]></title>
    <url>%2F2018%2F06%2F26%2FJava%E9%9B%86%E5%90%88-LinkedList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 1. 概述 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素–get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作–add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). 1234LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();list.add("语文: 1");list.add("数学: 2");list.add("英语: 3"); 结构也相对简单一些，如下图所示： 2. set和get函数123456789101112public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 这两个函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示： 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。 参考资料LinkedList (Java Platform SE 8)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-ArrayList工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】 原文链接 1. 概述关于Java集合的小抄中是这样描述的： 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 然后再来学习一下官方文档： Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。来看一段简单的代码： 12345ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("语文: 99");list.add("数学: 98");list.add("英语: 100");list.remove(0); 在执行这四条语句时，是这么变化的： 其中，add操作可以理解为直接将数组的内容置位，remove操作可以理解为删除index为0的节点，并将后面元素移到0处。 2. add函数当我们在ArrayList中增加元素的时候，会使用add函数。他会将元素放到末尾。具体实现如下： 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 我们可以看到他的实现其实最核心的内容就是ensureCapacityInternal。这个函数其实就是自动扩容机制的核心。我们依次来看一下他的具体实现 1234567891011121314151617181920212223242526272829private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩展为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩为1.5倍还不满足需求，直接扩为需求值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示： 3 set和get函数Array的put和get函数就比较简单了，先做index检查，然后执行赋值或访问操作： 12345678910111213public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 4 remove函数12345678910111213141516public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // 把后面的往前移 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 把最后的置null elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 注释很清楚： Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). 参考资料Class ArrayListArrayList其实就那么一回事儿之源码浅析关于ArrayList]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-TreeSet工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-TreeSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】 原文链接 1.概述 A NavigableSet implementation based on a TreeMap. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). TreeSet是基于TreeMap实现的，也非常简单，同样的只是用key及其操作，然后把value置为dummy的object。 123456789101112TreeSet&lt;String&gt; tset = new TreeSet&lt;String&gt;();tset.add("1语文");tset.add("3英语");tset.add("2数学");tset.add("4政治");tset.add("5历史");tset.add("6地理");tset.add("7生物");tset.add("8化学");for(String str : tset) &#123; System.out.println(str);&#125; 其具体的结构是： 利用TreeMap的特性，实现了set的有序性(通过红黑树实现)。 参考资料TreeSet(Java Platform SE 8)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-LinkedHashSet工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-LinkedHashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 1. 概述 Hash table and linked list implementation of the Set interface, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.) LinkedHashSet是基于HashMap和双向链表的实现。 123456789101112LinkedHashSet&lt;String&gt; lset = new LinkedHashSet&lt;String&gt;();lset.add("语文");lset.add("数学");lset.add("英语");lset.add("历史");lset.add("政治");lset.add("地理");lset.add("生物");lset.add("化学");for(String str : lset) &#123; System.out.println(str);&#125; 利用链表来记录，保证了迭代输出的有序性。其具体结构如下所示： 可以看出，其实现基本和LinkedHashMap一样。 2. 关键实现123public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable 从继承关系来看就知道LinkedHashMap的实现非常简单，就是集成HashSet的接口，并且在构造时调用的是： 123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 因此，结构也便是如HashSet于HashMap一样，LinkedHashSet也便如LinkedHashMap一样，只是将Value做了一个dummy的object。 参考资料LinkedHashSet]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-HashSet工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】 原文链接 1. 概述 This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，我们先来感性的认识一下这个结构： 123456789HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add("语文");set.add("数学");set.add("英语");set.add("历史");set.add("政治");set.add("地理");set.add("生物");set.add("化学"); 其大致的结构是这样的： 123private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); map是整个HashSet的核心，而PRESENT则是用来造一个假的value来用的。 2. 基本操作123456789101112131415public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;public boolean contains(Object o) &#123; return map.containsKey(o);&#125;public int size() &#123; return map.size();&#125; 基本操作也非常简单，就是调用HashMap的相关方法，其中value就是之前那个dummy的Object。所以，只要了解 HashMap的实现就可以了。 参考资料HashSet(Java Platform 8)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-TreeMap工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 1. 概述 A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest’s Introduction to Algorithms. 之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。 123456789101112TreeMap&lt;Integer, String&gt; tmap = new TreeMap&lt;Integer, String&gt;();tmap.put(1, "语文");tmap.put(3, "英语");tmap.put(2, "数学");tmap.put(4, "政治");tmap.put(5, "历史");tmap.put(6, "地理");tmap.put(7, "生物");tmap.put(8, "化学");for(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考数据结构之红黑树、wikipedia-红黑树等的实现 2. put函数 Associates the specified value with the specified key in this map.If the map previously contained a mapping for the key, the old value is replaced. 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //如果该节点存在，则替换值直接返回 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 如果该节点未存在，则新建 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树平衡调整 fixAfterInsertion(e); size++; modCount++; return null;&#125; 3. get函数get函数则相对来说比较简单，以log(n)的复杂度进行get 12345678910111213141516171819202122232425final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; // 按照二叉树搜索的方式进行搜索，搜到返回 while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125; 4. successor后继TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤 123for(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 根据The enhanced for statement，for语句会做如下转换为： 1234for(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123; Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 在it.next()的调用中会使用nextEntry调用successor这个是后继的重点，具体实现如下： 1234567891011121314151617181920212223static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; // 有右子树的节点，后继节点就是右子树的“最左节点” // 因为“最左子树”是右子树的最小节点 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; // 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点 // 因为左子树找完了，根据LDR该D了 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; // 保证左子树 while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下： a. 空节点，没有后继 b. 有右子树的节点，后继就是右子树的“最左节点” c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点 a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了 有右子树的节点，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是右子树的“最左节点”，就好像下图所示： 无右子树的节点，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。 相关链接TreeMap (Java Platform SE 8) 浅谈算法和数据结构: 九 平衡查找树之红黑树 Java提高篇（二七）——-TreeMap 数据结构之红黑树 wikipedia-红黑树 Red-Black Trees How TreeMap searches successor for given Entry?]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-集合框架概述]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 1. 概述什么是集合？这Java官方的入门文档是这样描述集合的： Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。 什么是集合框架？ Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了： Interfaces:这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构； Implementations:这些是接口的具体实现。本质上，是一些可复用的数据结构； Algorithms:这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。 除了Java的集合框架，还有一些著名的集合框架的例子：比如C++的STL和Smalltalk的集合架构。从历史上来看，集合框架可能比较复杂，也可能有一些很陡峭的学习曲线。不过我们相信Java的集合框架会突破这样的传统，在这章你就可以自己学会。 使用集合框架有什么好处？ Java的集合框架提供了一下优点： 减少编程的工作量：通过提供有用的数据结构和算法，集合框架能让你更专注的实现程序的核心功能，而不是去做一个底层的“管道工”。Java框架通过促进无关API的互操作性，使得你不用自己去实现不同API的适配 提高程序的速度与质量：集合框架提供了一些有用数据结构和算法的高性能、高质量的实现。每个接口的不同的实现也是可以互换的，所以程序可以通过切换集合来做一些调整。正因为你从实现数据结构的那些苦差事中脱离出来，你才可以有更多的实现去改善你自己程序的性能和质量 允许无关APIs的互操作：集合接口是API之间传递集合的一个“方言”，比如我的网络管理API有一个节点名的集合，而GUI工具需要一个列标题的集合，即使是分开实现它们，我们的APIs也可以无缝的接合。 省力地学习和使用新API：这是另一个领先的优势，设计者和实现者没必要在每次都重新设计API的时候都“推倒重来”地实现集合，而是直接使用标准的集合接口就好了。 促进软件的复用：符合标准集合接口的新数据结构本质上是可以复用的。对于操作这些新数据结构算法也是一样可以复用的。 因此，后面也便从接口、实现、算法几方面结合着代码和官方的文档学习总结一下。 2. 接口 在Java中所有的核心集合接口都是generic的 12345678910public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125;public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123;&#125;public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123;&#125;public interface Map&lt;K,V&gt; &#123;&#125;public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123;&#125;public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123;&#125; 也就是说在声明一个Collection的时候，应该指定一种类型。官方是这样解释原因的： Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. 下面就来介绍一下几种接口： Collection： 集合层次中的根。一个集合表示一组对象。有些有序，有些无序。有些重复，有些重复。Collection没有直接的实现，而只有它的子接口的对应的实现。 Set：不能包含重复的元素，比如扑克手牌、学生选课计划、计算机的进程。 List：有序的集合，也可以包含重复的元素。用于对每个元素精确的控制，比如插入、用index来索引。 Queue：用于多元素有优先级的处理，可以用做FIFO Deque：用于多元素有优先级的处理，double ended queue，可以用作FIFO，LIFO Map：用于keys到values的映射，不能包含重复元素另外还提供了2个带排序的Set和Map。 SortedSet：元素升序 SortedMap：key升序 在1.6版本开始，还有两种新的接口NavigableSet、NavigableMap。 A SortedMap/SortedSet extended with navigation methods reporting closest matches for given search targets. 提供诸如： 12//返回第一个大于e的元素E higher(E e); 之类的“导航性质”的便捷操作。 以上便是Java集合框架与接口的相关内容。 3. 类图 常见Map类相关的实现与继承关系 常见List Set类相关实现与继承关系]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-LinkedHashMap工作原理与实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 - （部分修改与补充） 1. 概述在理解了介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序： 123456789101112LinkedHashMap&lt;String, Integer&gt; lmap = new LinkedHashMap&lt;String, Integer&gt;();lmap.put("语文", 1);lmap.put("数学", 2);lmap.put("英语", 3);lmap.put("历史", 4);lmap.put("政治", 5);lmap.put("地理", 6);lmap.put("生物", 7);lmap.put("化学", 8);for(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 运行结果是： 语文: 1数学: 2英语: 3历史: 4政治: 5地理: 6生物: 7化学: 8 我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识： 没错，正如官方文档所说： Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。 2. 三个重点实现的函数在HashMap中提到了下面的定义： 1234// Callbacks to allow LinkedHashMap post-actionsvoid afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。 afterNodeAccess函数 12345678910111213141516171819202122232425void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 如果定义了accessOrder，那么就保证最近访问节点放到最后 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。 afterNodeInsertion函数 12345678void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; // 如果定义了移除规则，则执行相应的溢出 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; 如果用户定义了removeEldestEntry的规则，那么便可以执行相应的移除操作。 afterNodeRemoval函数 1234567891011121314void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink // 从链表中移除节点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 这个函数是在移除节点后调用的，就是将节点从双向链表中删除。 我们从上面3个函数看出来，基本上都是为了保证双向链表中的节点次序或者双向链表容量所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。 3. put和get函数put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。get函数则重新实现并加入了afterNodeAccess来保证访问顺序，下面是get函数的具体实现： 12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生structural modification。官方文档是这么描述的： A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. 不要犯了像ConcurrentModificationException with LinkedHashMap类似的问题。 总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。:-) 参考链接Class LinkedHashMapConcurrentModificationException with LinkedHashMap]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-HashMap工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】原文链接 - （部分修改与补充） 1. 概述 从本文你可以学习到： 什么时候会使用HashMap？他有什么特点？ 你知道HashMap的工作原理吗？ 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？ 你知道hash的实现吗？为什么要这样实现？ 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 当我们执行下面的操作时： 123456789101112HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put("语文", 1);map.put("数学", 2);map.put("英语", 3);map.put("历史", 4);map.put("政治", 5);map.put("地理", 6);map.put("生物", 7);map.put("化学", 8);for(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 运行结果是 政治: 5生物: 7历史: 4数学: 2化学: 8语文: 1英语: 3地理: 6 发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识： 在官方文档中是这样描述HashMap的： Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. 几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。 2. 两个重要的参数在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor) Initial capacity The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created. Load factor The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. 简单的说，Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket填充的数目（即hashmap中元素的个数）大于capacity*load factor时就需要调整buckets的数目为当前的2倍。 3. put函数的实现put函数大致的思路为： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 具体代码的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 节点存在 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 写入 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 超过load factor*current capacity，resize if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 4. get函数的实现在理解了put之后，get就很简单了。大致思路如下： bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。 具体代码的实现如下： 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 直接命中 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 未命中 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 5. hash函数的实现在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：(移位 - 异或 - 与运算) 在对hashCode()计算hash时具体实现是这样的： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的： Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds. 在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： 1(n - 1) &amp; hash 设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。 因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。 如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题： Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. 之前已经提过，在获取HashMap的元素时，基本分两步： 首先根据hashCode()做hash，然后确定bucket的index； 如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。 因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。 6. RESIZE的实现当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的： Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table. 大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 下面是代码的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 7. 总结我们现在可以回答开始的几个问题，加深对HashMap的理解： 1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。 关于Java集合的小抄中是这样描述的： 以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。 插入元素时，如果两条Key落在同一个桶（比如哈希值1和17取模16后都属于第一个哈希桶），我们称之为哈希冲突。 JDK的做法是链表法，Entry用一个next属性实现多个Entry以单向链表存放。查找哈希值为17的key时，先定位到哈希桶，然后链表遍历桶里所有元素，逐个比较其Hash值然后key值。 在JDK8里，新增默认为8的阈值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。 当然，最好还是桶里只有一个元素，不用去比较。所以默认当Entry数量达到桶数量的75%时，哈希冲突已比较严重，就会成倍扩容桶数组，并重新分配所有原来的Entry。扩容成本不低，所以也最好有个预估值。 取模用与操作（hash &amp; （arrayLength-1））会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。 iterator（）时顺着哈希桶数组来遍历，看起来是个乱序 参考资料HashMap的工作原理Java 8：HashMap的性能提升JEP 180: Handle Frequent HashMap Collisions with Balanced TreesConurrentHashMap和Hashtable的区别HashMap和Hashtable的区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-EnumMap工作原理及实现]]></title>
    <url>%2F2018%2F06%2F25%2FJava%E9%9B%86%E5%90%88-EnumMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【转载】 原文链接 - （部分修改与补充） 1. 概述 A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. EnumMap是是一种键为枚举类型的特殊的Map实现。所有的Key也必须是一种枚举类型，EnumMap是使用数组来实现的。（两个数组，一个数组keyUniverse存储key，另一个数组vals存储val，两个数组通过下标对应起来） 12345678EnumMap&lt;Course, String&gt; map = new EnumMap&lt;Course, String&gt;(Course.class);map.put(Course.ONE, "语文");map.put(Course.ONE, "政治");map.put(Course.TWO, "数学");map.put(Course.THREE, "英语");for(Entry&lt;Course, String&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 输出结果（按照枚举类中的顺序遍历数组，按数组下标依次输出（跳过空））为： 123ONE: 政治TWO: 数学THREE: 英语 其具体实现的结构如下图所示： 2. put和get方法put方法通过key的ordinal将值存储到对应的地方，get方法则根据key的ordinal获取对应的值。 123456789101112131415161718public V put(K key, V value) &#123; // 类型检查 typeCheck(key); // 获取key的序号 int index = key.ordinal(); Object oldValue = vals[index]; // 赋值 vals[index] = maskNull(value); // 若之前的值为空，则size++ if (oldValue == null) size++; return unmaskNull(oldValue);&#125;public V get(Object key) &#123; return (isValidKey(key) ? unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : null);&#125; 3. 遍历EnumMapIterator的迭代这样实现的： 123456789101112public boolean hasNext() &#123; while (index &lt; vals.length &amp;&amp; vals[index] == null) index++; return index != vals.length;&#125;public Map.Entry&lt;K,V&gt; next() &#123; if (!hasNext()) throw new NoSuchElementException(); lastReturnedEntry = new Entry(index++); return lastReturnedEntry;&#125; 通过hasNext跳过空的数组，也就是说，保证了遍历顺序与Enum中key的先后顺序一致。 参考资料What is EnumMap in Java]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitPage+Gitments+yilia博客搭建手记]]></title>
    <url>%2F2018%2F06%2F22%2FHexo-GitPage-Gitments-yilia%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[说明: 经过两天的折腾, 也算把这个事情搞定了,顺手写下这边手记.笔者之前已经使用SpringBoot搭建了个人博客站点, 博客预览 . 完整代码已开源,可见博客站点的说明页. 而之所以又着手搭建这个站点,主要考虑到,那个服务器租期为一年,后期维护麻烦,为减少成本,打算慢慢迁移至此. 这边随笔主要记录使用Hexo+GitHub搭建博客的流程,希望对您有所帮助,喜欢点个Star,谢谢. 1. 主要步骤 安装Git、 Node.js(本文示例为Windows平台) 创建Github仓库,开启GitPage 安装、使用Hexo,更换主题 图床、 Markdown编辑器 多端同步，Gitment评论等其他问题 2. 安装Git、Node.js 安装Git，本文就不详述步骤，具体可参考-廖雪峰Git教程 安装Node.js，下载网站，笔者下载的是LTS-Windows64位 5.6.0安装版本 安装时注意保持勾选 add to path，任意目录右键 Git Bash Here，输入 npm -v，检验安装是否成功，显示版本号，则表示正常 3. 创建GitHub仓库，设为GitPages 创建一个仓库，命名为 用户名.github.io,如 briarbear.github.io 这样的命名即为开启 GitPages，点开仓库的setting，可以看到GitHub Pages说明 则博客站点域名即为 用户名.github.io 4. 安装Hexo 安装教程可参看 官方文档，中文版，详尽易懂 主要步骤为 安装： npm install -g hexo-cli 初始化： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 配置：重点配置deploy ，使用Git同步方式与GItHub同步，具体详见 官方说明 如笔者的配置，完整的详细配置，可见文末本博客站点的开源： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: gitrepo: git@github.com:briarbear/briarbear.github.io.gitbranch: master 安装Git插件：npm install hexo-deployer-git --save 启动： 此时就可以依次输入命令； hexo clean， hexo generate, hexo server 即本地启动完成：在浏览器输入：http://localhost:4000,即可以看到初始效果 5. 使用Hexo 常用命令: 123456789101112131415161718hexo init [folder] # 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。hexo new [layout] &lt;title&gt;#新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。hexo generate # 生成静态文件。-d 文件生成后立即部署网站 -w 监视文件变动 hexo g #简写hexo publish [layout] &lt;filename&gt; # 发表草稿。hexo server# 启动服务器。默认情况下，访问网址为： http://localhost:4000/。# -p 重设端口 -s 只使用静态文件 -l 启动日志记录hexo deploy # 部署网站。-g 部署之前预先生成静态文件hexo d #简写hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。 6. 使用主题 hexo官方提供了大量的 优秀主题，如果选中某款主题，点击主题，移至页面底部，一般都可以看到主题的版权说明，点击即可以进入主题的github仓库，如选中第一个主题A-RSnippet，下图所示： 笔者使用的 yilia主题 在hexo的目录中，主题文件位于 ./themes, 主题的主要流程 在主题目录中，git clone 主题仓库 修改主题的配置文件：_config.yml 具体使用流程，可参考一个 yilla主题使用教程 如果喜欢笔者的主题,已做了一些修改，可以在文本的github仓库中clone下来，./themes/yilla 7. Markdown编辑器与图床 笔者使用的 Typora编辑器，一款非常优秀的markdown编辑器，满足你对markdown编辑器所有的幻想，（即时预览，仅此一家） 在hexo中，使用hexo new新建文章后，再去./source/_posts目录下找到目标文档，使用Typora编辑器编辑 而使用Markdown编辑器，我们经常会遇到图片问题，这里提供两种处理方案 第一种方案：【相对路径】在hexo配置文件中，开启 post_asset_folder: true，新建文件会生成文件对应的文件夹，在markdown中可以使用相对路径来引用图片 第二种方案：【绝对路径】笔者使用的方案，使用在线的图床，这样可以更好的方便使用markdown文件，在任意地方打开都能正确的渲染，而使用绝对路径，就得使用图床网站来保存图片 关于图床 推荐 七牛云，实名认证，送免费存储空间，存储图片够用 但是，使用图床，如果我们每次使用一个图片，都要先上传到图床，再复制外链，再粘贴 ，这样效率就低的可怕，有没有一种工具，我复制一张图片，后台自动上传到图床，然后返回外链至剪切板，这样在markdown编辑器中直接就可以使用呢？ 有，当然有！！！！Mac下有付费的应用，Windows下推荐 qImage，使用方法参看具体链接 最终效果：使用 Alt + S 截图（推荐截图贴图软件 snipaste ），复制图片，在typora中使用快捷键 Ctrl + Alt + V，则直接生成图片 8. 多端同步与Gitment 在hexo中，通过git连接github仓库，它同步的文件实际上仅为经过hexo生成的静态文件，那么怎样将源文件在多端同步，这样是可以在多台设备都可以编辑博客，解决思路：Git 分支 详细的解决方案，知乎：使用hexo，如果换了电脑怎么更新博客？ 到此为止，静态博客基本可用，但由于是静态网站，无法评论，解决思路是结合Gitments来解决，同时，yilia主题也提供了多种评论方式，具体可参看 wiki 而使用Gitments，使用教程 笔者的配置文件 相关链接 GitHub+Hexo 搭建个人网站详细教程 Hexo中文文档 Gitment：使用 GitHub Issues 搭建评论系统 知乎：使用hexo，如果换了电脑怎么更新博客？ 一个简洁优雅的hexo主题 yilia]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2F2018%2F06%2F21%2Fabout%2F</url>
    <content type="text"><![CDATA[关于我 xiongzp08]]></content>
  </entry>
</search>
